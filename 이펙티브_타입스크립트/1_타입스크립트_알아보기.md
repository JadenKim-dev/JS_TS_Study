# 타입스크립트 알아보기
타입스크립트는 인터프리터로 바로 실행되는 것도 아니고, 저수준 언어로 컴파일 되는 것도 아니다.  
또다른 고수준 언어인 자바스크립트로 컴파일 되어서 실행되는 독특한 구조를 가진 언어이다.  
타입스크립트와 자바스크립트는 서로 밀접한 관계를 가지기 때문에, 둘의 관계를 제대로 이해하고 사용해야 한다.

## 1. 타입스크립트와 자바스크립트의 관계 이해하기

### 타입스크립트는 자바스크립트의 상위 집합

타입스크립트는 문법적으로 자바스크립트의 상위 집합이다.  
유효한 자바스크립트 코드는 타입스크립트에서도 유효하며, js 파일들을 그대로 ts 파일로 변경해도 문제 없이 컴파일 된다.

> 이로 인해 기존의 js 코드를 ts로 마이그레이션 할 때, 일부 파일에만 ts를 적용하면서 점진적으로 변환하는 것이 가능하다.

하지만 타입이 적용된 ts 파일에는 js에서 지원하지 않는 문법이 추가되므로, 타입스크립트는 자바스크립트가 될 수 없다.

```
function greet(who: string) {
                  ^
  SyntaxError: Unexpected token :
}
```

타입스크립트는 정적 타입 시스템으로, 런타임에 에러를 발생시킬 코드를 컴파일 타임에 미리 찾아내는 것을 목표로 한다.  
ts의 타입 체커는 문법 상의 오류를 잡아내며, 타입이 명시되지 않았더라도 초기값으로부터 타입을 유추해낸다.  
이 점 덕분에 js를 그대로 사용해도 타입 체커가 정상적으로 동작한다.

```ts
let city = 'new york city';
console.log(city.toUppercase());
//~~~~~~~~~~~ 'toUppercase' 속성이 'string' 형식에 없습니다.
```

타입 체킹을 거치면 의도와 다르게 동작할 수 있는 코드를 미리 잡아낼 수 있다.  
예를 들어 변수명에 오타가 있어서 존재하지 않는 변수를 참조하려고 할 때, 타입 오류로 미리 감지할 수 있다.

```js
const states = [
  {name: 'Alabama', capital: 'Montgomery'},
  {name: 'Alaska', capital: 'Juneau1'},
]；
for (const state of states) {
  console.log(state.capitol);
                 // ~~~~~~~ ‘capitol’ 속성이 ... 형식에 없습니다.
                 // 'capital'을 사용하시겠습니까?
}
```

이제 states에 대한 명시적인 타입까지 선언한다면, 코드가 의도대로 작성되었음을 더 확실히 보장할 수 있다.  
예를 들어 states의 각 요소에 대한 정의에서 오류가 있었다면 타입 체크를 통해 잡아낼 수 있다.

```ts
interface State {
  name: string;
  capital: string;
}
const states: State[] = [
  {name: 'Alabama', capitol: 'Montgomery'},
                  //~~~~~~~~~~~~~~~~~~~~~ 개체 리터럴은 알려진 속성만 지정할 수 있지만
                  //                      'State' 형식에 'capitol'이（가） 없습니다.
                  //                      'capital'을（를） 쓰려고 했습니까?
]
```

모든 js 프로그램은 ts 프로그램에 속하지만, 일부의 js 프로그램만이 ts 타입 체커를 통과할 수 있다.  
또한 명시적인 타입 선언을 갖춘 타입스크립트 프로그램이 그 외의 영역에 존재한다.  
타입을 정의하고 적용함으로써 개발자의 의도가 보다 명확하게 드러난다.

### 타입스크립트는 자바스크립트의 런타임 동작을 모델링 한다.

타입스크립트의 타입 시스템은 기본적으로 자바스크립트의 런타임 동작을 모델링 한다.  
예를 들어 다음과 같은 `숫자 -> 문자열` 변환의 경우 자동으로 인식해서 타입을 유추한다.

```ts
const x = 2 + '3'; // string
const y = '2' + 3; // string
```

하지만 js 런타임에는 문제가 없지만 ts 타입 체크에서 오류로 인식하는 문법들도 있다.  
객체나 배열에 숫자를 더하거나, 매개변수를 초과해서 호출하는 등의 경우이다.

```ts
const a = null + 7;
        //~~~~ '+' 연산자를 ... 형식에 적용할 수 없습니다.
const b = [] + 12;
        //~~ '+' 연산자를 ... 형식에 적용할 수 없습니다.
alert ('Hello1', 'TypeScript');
              //~~~~~~~~~~~~ 0-1개의 인수가 필요한데 2개를 가져왔습니다.
```

js는 유연하게 동작하는 언어이고, 일반적인 언어에서는 오류로 판단할 만한 로직들이 정상적으로 동작하는 경우가 많다.  
ts의 타입 시스템의 목적은 런타임에 발생하는 에러들 뿐만 아니라, 의도치 않게 동작할 가능성이 높은 코드들까지 잡아내는 것이다.  
따라서 js 런타임에서 정상 동작하는 코드더라도 타입 체크를 통과하지 못할 수 있다.

또한 타입 시스템이 모든 런타임 예외를 잡아낼 수 있는 것은 아니다.  
예를 들어 배열에서 존재하지 않는 인덱스의 객체를 참조하는 등의 예외는 잡아낼 수 없다.  
이러한 예외들은 타입 체계와 무관하게 개발자가 주의해서 잡아내야 한다.

## 2. 타입스크립트 설정 이해하기

타입스크립트 컴파일러는 매우 다양한 설정을 가지고 있고, 커맨드 라인 옵션이나 tsconfig.json 파일을 통해 해당 옵션들을 지정할 수 있다.  
설정들은 어떤 파일들을 컴파일 할지, 출력 파일의 형태가 무엇인디 등의 기본 정보들과 함께, 언어의 핵심 요소를 설정하는 정보도 있다.  
noImplicitAny와 strictNullChecks는 대표적인 고수준 설계의 설정들이다.  
이들의 설정 값에 따라 타입스크립트는 완전히 다른 언어처럼 동작한다.

noImplicitAny는 암시적으로 any 타입으로 유추하는 것을 금지하는 설정이다.  
예를 들어 다음 코드의 경우 noImplicitAny가 설정되어 있지 않다면, 매개변수가 모두 any로 유추되어 타입 체커를 통과한다.

```ts
function add(a, b) {
  return a + b;
}
// function add(a: any, b: any): any
```

타입스크립트는 가능한 명시적으로 타입 정보를 제공하도록 해야 타입 체커가 온전히 작동할 수 있다.  
위 예시의 경우 매개변수의 타입을 명시함으로써 noImplicitAny 설정을 한 타입체커를 통과할 수 있다.

```ts
function add(a: number, b: number) {
  return a + b;
}
```

noImplicitAny 설정을 해제하는 것은 자바스크립트 프로젝트를 타입스크립트로 전환하는 상황에만 한시적으로 허용된다.  
그 외의 경우에는 가능한 noImplicitAny를 설정하여 코드를 작성할 때마다 타입을 명시하도록 해야 한다.

strictNullChecks는 undefined와 null과 관련한 타입을 엄격하게 체크할지를 설정하는 값이다.  
strictNullChecks가 설정되었을 때에는 일반 타입과 undefined/null이 명확히 구분되며, 관련된 처리를 해야 타입 체크에 통과할 수 있다.  
예를 들어 strictNullChecks가 설정되어 있을 때 다음 코드는 타입체커에 걸리게 된다.

```ts
const x: number = null;
//    ~ 'null' 형식은 'number' 형식에 할당할 수 없습니다.
const x: number = undefined;
//    ~ 'undefined' 형식은 'number' 형식에 할당할 수 없습니다.
```

null을 할당하기 위해서는 타입 지정 시 명시적으로 null을 허용해야 한다.

```ts
const x: number | null = null;
```

또한 nullable한 변수들은 null 체크나 타입 단언을 거쳐야 일반 타입으로 사용할 수 있다.

```ts
  const el = document.getElementById('status1');
  el.textcontent = 'Ready';
//~~ 개체가 'null'인 것 같습니다.

// null 체크
  if (el) {
    el.textcontent = 'Ready';
  }
// 타입 단언
  el!.textcontent = 'Ready';
```

strictNullChecks를 설정하기 위해서는 null 체크 코드가 많은 부분에 추가되어야 한다.  
이로 인해 설정에 난이도가 높은 편이지만, 런타임에서 'undefined는 객체가 아닙니다.' 같은 에러가 발생하는 것을 상당 부분 방지할 수 있다.

## 3. 코드 생성과 타입이 관계 없음을 이해하기

타입스크립트 컴파일러는 ts 코드를 js로 변환하는 작업과, 코드의 타입 오류를 체크하는 작업을 수행한다.  
이 때 두 작업이 서로 독립적으로 수행된다는 점을 기억해야 한다.

### 타입 오류가 있는 코드도 컴파일이 가능하다.

타입 오류가 있더라도 js로의 변환은 문제 없이 가능하다.

```ts
let x = 'hello';
x = 1234;
// test.ts:2:1 - error TS2322: '1234' 형식은 'string' 형식에 할당할 수 없습니다.

// 컴파일 결과
var x = 'hello';
x = 1234;
```

해당 특성 덕분에 ts 코드의 일부에 타입 오류가 있다라도, 컴파일을 해서 코드를 실행하고 테스트 할 수 있다.

### 런타임에는 타입 체크가 불가능하다.

또한 ts에서 변환된 js를 실행할 때 모든 타입, 인터페이스는 제거된다.  
흔히 하는 실수가 instanceof를 타입에 적용하는 것인데, instanceof는 런타임에 동작하기 때문에 타입을 이용할 수 없다.

```ts
interface Square {
  width: number;
}
interface Rectangle extends Square {
  height: number;
}
type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
                    // ~~~~~~~~~ 'Rectangle은(는) 형식만 참조하지만, 
                    //           여기서는 값으로 사용되고 있습니다.
    return shape.width * shape.height;
                            // ~~~~~~ 'Shape' 형식에 'height' 속성이 없습니다.
  } else {
    return shape.width * shape.width;
  }
}
```

런타임에서 타입을 구분하기 위해서는, 런타임에도 유지되는 정보를 이용해서 타입을 체크해야 한다.  
먼저 타입에 종속된 프로퍼티가 존재하는지 체크히는 방법이 있다.  
위 예시에서 height 속성은 Rectangle에 종속되므로, height 프로퍼티가 존재하는지 확인하면 된다.  
이 때 타입 체커는 자동으로 shape의 타입을 Rectangle로 보정해준다.

```ts
function calculateArea(shape: Shape) {
  if ('height' in shape) {
    shape; // 타입이 Rectangle
    return shape.width * shape.height;
  } else {
    shape; // 타입이 Square
    return shape.width * shape.width;
  }
}
```

또한 런타임에 접근 가능하도록 타입 정보를 명시적으로 지정하는 태그 기법도 있다.  
예를 들어 위 예시에서는 kind 프로퍼티에 태그 정보를 삽입하도록 타입을 정의할 수 있다.  
이 때 Shape는 태그된 유니온 타입이 된다.

```ts
interface Square {
    kind: 'square';
    width: number;
}

interface Rectangle {
    kind: 'rectangle';
    height: number;
    width: number;
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
    if (shape.kind === 'rectangle') {
        // 타입이 Rectangle
        return shape.width * shape.height;
    } else {
        // 타입이 Square
        return shape.width * shape.width;
    }
}
```

또는 타입을 클래스로 정의하여 값과 타입으로 동시에 사용할 수 있도록 하는 방법도 있다.  
이 때 `type Shape = Square | Rectangle` 같은 부분에서 Rectangle은 타입으로 참조되지만, `shape instanceof Rectangle` 같은 부분에서는 값으로 참조된다.

```ts
class Square {
    constructor(public width: number) {}
}

class Rectangle extends Square {
    constructor(public width: number, public height: number) {
        super(width);
    }
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
    if (shape instanceof Rectangle) {
        // 타입이 Rectangle
        return shape.width * shape.height;
    } else {
        // 타입이 Square
        return shape.width * shape.width; // 정상
    }
}
```

### 타입 연산은 런타임에 영향을 주지 않는다.

또한 타입 단언을 포함한 타입 연산은 런타임에 영향을 주지 않는다는 점을 주의해야 한다.  
예를 들어 다음 코드는 런타임에서는 타입 변환을 수행하지 못한다.

```ts
function asNumber(val: number | string): number {
  return val as number;
}

// 컴파일 결과
function asNumber(val) {
  return val;
}
```

런타임의 타입 변환을 위해서는 자바스크립트 연산을 이용하여 타입 체크 및 변환을 수행해야 한다.

```ts
function asNumber(val: number | string): number {
  return typeof(val) === 'string' ? Number(val) : val;
}
```









