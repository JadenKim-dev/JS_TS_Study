# 타입스크립트 알아보기

타입스크립트는 인터프리터로 바로 실행되는 것도 아니고, 저수준 언어로 컴파일 되는 것도 아니다.  
또다른 고수준 언어인 자바스크립트로 컴파일 되어서 실행되는 독특한 구조를 가진 언어이다.  
타입스크립트와 자바스크립트는 서로 밀접한 관계를 가지기 때문에, 둘의 관계를 제대로 이해하고 사용해야 한다.

## 1. 타입스크립트와 자바스크립트의 관계 이해하기

### 타입스크립트는 자바스크립트의 상위 집합

타입스크립트는 문법적으로 자바스크립트의 상위 집합이다.  
유효한 자바스크립트 코드는 타입스크립트에서도 유효하며, js 파일들을 그대로 ts 파일로 변경해도 문제 없이 컴파일 된다.

> 이로 인해 기존의 js 코드를 ts로 마이그레이션 할 때, 일부 파일에만 ts를 적용하면서 점진적으로 변환하는 것이 가능하다.

하지만 타입이 적용된 ts 파일에는 js에서 지원하지 않는 문법이 추가되므로, 타입스크립트는 자바스크립트가 될 수 없다.

```
function greet(who: string) {
                  ^
  SyntaxError: Unexpected token :
}
```

타입스크립트는 정적 타입 시스템으로, 런타임에 에러를 발생시킬 코드를 컴파일 타임에 미리 찾아내는 것을 목표로 한다.  
ts의 타입 체커는 문법 상의 오류를 잡아내며, 타입이 명시되지 않았더라도 초기값으로부터 타입을 유추해낸다.  
이 점 덕분에 js를 그대로 사용해도 타입 체커가 정상적으로 동작한다.

```ts
let city = 'new york city';
console.log(city.toUppercase());
//~~~~~~~~~~~ 'toUppercase' 속성이 'string' 형식에 없습니다.
```

타입 체킹을 거치면 의도와 다르게 동작할 수 있는 코드를 미리 잡아낼 수 있다.  
예를 들어 변수명에 오타가 있어서 존재하지 않는 변수를 참조하려고 할 때, 타입 오류로 미리 감지할 수 있다.

```js
const states = [
  { name: 'Alabama', capital: 'Montgomery' },
  { name: 'Alaska', capital: 'Juneau1' },
]；
for (const state of states) {
  console.log(state.capitol);
                 // ~~~~~~~ ‘capitol’ 속성이 ... 형식에 없습니다.
                 // 'capital'을 사용하시겠습니까?
}
```

이제 states에 대한 명시적인 타입까지 선언한다면, 코드가 의도대로 작성되었음을 더 확실히 보장할 수 있다.  
예를 들어 states의 각 요소에 대한 정의에서 오류가 있었다면 타입 체크를 통해 잡아낼 수 있다.

```ts
interface State {
  name: string;
  capital: string;
}
const states: State[] = [
  { name: 'Alabama', capitol: 'Montgomery' },
                  //~~~~~~~~~~~~~~~~~~~~~ 개체 리터럴은 알려진 속성만 지정할 수 있지만
                  //                      'State' 형식에 'capitol'이（가） 없습니다.
                  //                      'capital'을（를） 쓰려고 했습니까?
]
```

모든 js 프로그램은 ts 프로그램에 속하지만, 일부의 js 프로그램만이 ts 타입 체커를 통과할 수 있다.  
또한 명시적인 타입 선언을 갖춘 타입스크립트 프로그램이 그 외의 영역에 존재한다.  
타입을 정의하고 적용함으로써 개발자의 의도가 보다 명확하게 드러난다.

### 타입스크립트는 자바스크립트의 런타임 동작을 모델링 한다.

타입스크립트의 타입 시스템은 기본적으로 자바스크립트의 런타임 동작을 모델링 한다.  
예를 들어 다음과 같은 `숫자 -> 문자열` 변환의 경우 자동으로 인식해서 타입을 유추한다.

```ts
const x = 2 + '3'; // string
const y = '2' + 3; // string
```

하지만 js 런타임에는 문제가 없지만 ts 타입 체크에서 오류로 인식하는 문법들도 있다.  
객체나 배열에 숫자를 더하거나, 매개변수를 초과해서 호출하는 등의 경우이다.

```ts
const a = null + 7;
        //~~~~ '+' 연산자를 ... 형식에 적용할 수 없습니다.
const b = [] + 12;
        //~~ '+' 연산자를 ... 형식에 적용할 수 없습니다.
alert ('Hello1', 'TypeScript');
              //~~~~~~~~~~~~ 0-1개의 인수가 필요한데 2개를 가져왔습니다.
```

js는 유연하게 동작하는 언어이고, 일반적인 언어에서는 오류로 판단할 만한 로직들이 정상적으로 동작하는 경우가 많다.  
ts의 타입 시스템의 목적은 런타임에 발생하는 에러들 뿐만 아니라, 의도치 않게 동작할 가능성이 높은 코드들까지 잡아내는 것이다.  
따라서 js 런타임에서 정상 동작하는 코드더라도 타입 체크를 통과하지 못할 수 있다.

또한 타입 시스템이 모든 런타임 예외를 잡아낼 수 있는 것은 아니다.  
예를 들어 배열에서 존재하지 않는 인덱스의 객체를 참조하는 등의 예외는 잡아낼 수 없다.  
이러한 예외들은 타입 체계와 무관하게 개발자가 주의해서 잡아내야 한다.

## 2. 타입스크립트 설정 이해하기

타입스크립트 컴파일러는 매우 다양한 설정을 가지고 있고, 커맨드 라인 옵션이나 tsconfig.json 파일을 통해 해당 옵션들을 지정할 수 있다.  
설정들은 어떤 파일들을 컴파일 할지, 출력 파일의 형태가 무엇인디 등의 기본 정보들과 함께, 언어의 핵심 요소를 설정하는 정보도 있다.  
noImplicitAny와 strictNullChecks는 대표적인 고수준 설계의 설정들이다.  
이들의 설정 값에 따라 타입스크립트는 완전히 다른 언어처럼 동작한다.

noImplicitAny는 암시적으로 any 타입으로 유추하는 것을 금지하는 설정이다.  
예를 들어 다음 코드의 경우 noImplicitAny가 설정되어 있지 않다면, 매개변수가 모두 any로 유추되어 타입 체커를 통과한다.

```ts
function add(a, b) {
  return a + b;
}
// function add(a: any, b: any): any
```

타입스크립트는 가능한 명시적으로 타입 정보를 제공하도록 해야 타입 체커가 온전히 작동할 수 있다.  
위 예시의 경우 매개변수의 타입을 명시함으로써 noImplicitAny 설정을 한 타입체커를 통과할 수 있다.

```ts
function add(a: number, b: number) {
  return a + b;
}
```

noImplicitAny 설정을 해제하는 것은 자바스크립트 프로젝트를 타입스크립트로 전환하는 상황에만 한시적으로 허용된다.  
그 외의 경우에는 가능한 noImplicitAny를 설정하여 코드를 작성할 때마다 타입을 명시하도록 해야 한다.

strictNullChecks는 undefined와 null과 관련한 타입을 엄격하게 체크할지를 설정하는 값이다.  
strictNullChecks가 설정되었을 때에는 일반 타입과 undefined/null이 명확히 구분되며, 관련된 처리를 해야 타입 체크에 통과할 수 있다.  
예를 들어 strictNullChecks가 설정되어 있을 때 다음 코드는 타입체커에 걸리게 된다.

```ts
const x: number = null;
//    ~ 'null' 형식은 'number' 형식에 할당할 수 없습니다.
const x: number = undefined;
//    ~ 'undefined' 형식은 'number' 형식에 할당할 수 없습니다.
```

null을 할당하기 위해서는 타입 지정 시 명시적으로 null을 허용해야 한다.

```ts
const x: number | null = null;
```

또한 nullable한 변수들은 null 체크나 타입 단언을 거쳐야 일반 타입으로 사용할 수 있다.

```ts
  const el = document.getElementById('status1');
  el.textcontent = 'Ready';
//~~ 개체가 'null'인 것 같습니다.

// null 체크
  if (el) {
    el.textcontent = 'Ready';
  }
// 타입 단언
  el!.textcontent = 'Ready';
```

strictNullChecks를 설정하기 위해서는 null 체크 코드가 많은 부분에 추가되어야 한다.  
이로 인해 설정에 난이도가 높은 편이지만, 런타임에서 'undefined는 객체가 아닙니다.' 같은 에러가 발생하는 것을 상당 부분 방지할 수 있다.

## 3. 코드 생성과 타입이 관계 없음을 이해하기

타입스크립트 컴파일러는 ts 코드를 js로 변환하는 작업과, 코드의 타입 오류를 체크하는 작업을 수행한다.  
이 때 두 작업이 서로 독립적으로 수행된다는 점을 기억해야 한다.

### 타입 오류가 있는 코드도 컴파일이 가능하다.

타입 오류가 있더라도 js로의 변환은 문제 없이 가능하다.

```ts
let x = 'hello';
x = 1234;
// test.ts:2:1 - error TS2322: '1234' 형식은 'string' 형식에 할당할 수 없습니다.

// 컴파일 결과
var x = 'hello';
x = 1234;
```

해당 특성 덕분에 ts 코드의 일부에 타입 오류가 있다라도, 컴파일을 해서 코드를 실행하고 테스트 할 수 있다.

### 런타임에는 타입 체크가 불가능하다.

또한 ts에서 변환된 js를 실행할 때 모든 타입, 인터페이스는 제거된다.  
흔히 하는 실수가 instanceof를 타입에 적용하는 것인데, instanceof는 런타임에 동작하기 때문에 타입을 이용할 수 없다.

```ts
interface Square {
  width: number;
}
interface Rectangle extends Square {
  height: number;
}
type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
                    // ~~~~~~~~~ 'Rectangle은(는) 형식만 참조하지만, 
                    //           여기서는 값으로 사용되고 있습니다.
    return shape.width * shape.height;
                            // ~~~~~~ 'Shape' 형식에 'height' 속성이 없습니다.
  } else {
    return shape.width * shape.width;
  }
}
```

런타임에서 타입을 구분하기 위해서는, 런타임에도 유지되는 정보를 이용해서 타입을 체크해야 한다.  
먼저 타입에 종속된 프로퍼티가 존재하는지 체크히는 방법이 있다.  
위 예시에서 height 속성은 Rectangle에 종속되므로, height 프로퍼티가 존재하는지 확인하면 된다.  
이 때 타입 체커는 자동으로 shape의 타입을 Rectangle로 보정해준다.

```ts
function calculateArea(shape: Shape) {
  if ('height' in shape) {
    shape; // 타입이 Rectangle
    return shape.width * shape.height;
  } else {
    shape; // 타입이 Square
    return shape.width * shape.width;
  }
}
```

또한 런타임에 접근 가능하도록 타입 정보를 명시적으로 지정하는 태그 기법도 있다.  
예를 들어 위 예시에서는 kind 프로퍼티에 태그 정보를 삽입하도록 타입을 정의할 수 있다.  
이 때 Shape는 태그된 유니온 타입이 된다.

```ts
interface Square {
  kind: 'square';
  width: number;
}

interface Rectangle {
  kind: 'rectangle';
  height: number;
  width: number;
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape.kind === 'rectangle') {
    // 타입이 Rectangle
    return shape.width * shape.height;
  } else {
    // 타입이 Square
    return shape.width * shape.width;
  }
}
```

또는 타입을 클래스로 정의하여 값과 타입으로 동시에 사용할 수 있도록 하는 방법도 있다.  
이 때 `type Shape = Square | Rectangle` 같은 부분에서 Rectangle은 타입으로 참조되지만, `shape instanceof Rectangle` 같은 부분에서는 값으로 참조된다.

```ts
class Square {
  constructor(public width: number) {}
}

class Rectangle extends Square {
  constructor(public width: number, public height: number) {
    super(width);
  }
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    // 타입이 Rectangle
    return shape.width * shape.height;
  } else {
    // 타입이 Square
    return shape.width * shape.width; // 정상
  }
}
```

### 타입 연산은 런타임에 영향을 주지 않는다.

또한 타입 단언을 포함한 타입 연산은 런타임에 영향을 주지 않는다는 점을 주의해야 한다.  
예를 들어 다음 코드는 런타임에서는 타입 변환을 수행하지 못한다.

```ts
function asNumber(val: number | string): number {
  return val as number;
}

// 컴파일 결과
function asNumber(val) {
  return val;
}
```

런타임의 타입 변환을 위해서는 자바스크립트 연산을 이용하여 타입 체크 및 변환을 수행해야 한다.

```ts
function asNumber(val: number | string): number {
  return typeof(val) === 'string' ? Number(val) : val;
}
```

### 런타임 타입은 선언된 타입과 다를 수 있다.

자바스크립트 런타임에서의 타입과 타입스크립트에서 정의한 타입은 불일치할 수 있다.  
특히 사용자의 입력을 받거나, 외부에서 값을 받아오는 부분에서 이러한 문제가 생기기 쉽다.  
예를 들어 매개변수로 boolean을 받는 다음과 같은 메서드가 정의되었다고 해보자.

```ts
function setLightSwitch(value: boolean) {
  switch (value) {
    case true:
      turnLightOn();
      break;
    case false:
      turnLightOff();
      break;
    default:
      console.log('예상치 못한 값입니다.');
  }
}
```

이 때 타입 체계에 의해 default 문이 실행되는 경우는 없다고 생각할 수 있다.  
하지만 외부 API의 반환 타입을 잘못 이해한 상태에서 외부 통신으로 값을 받아올 경우에는 다른 타입의 값이 삽입될 수 있다.  
아래 예시에서는 lightSwitchValue가 boolean이 아닌 'ON'과 같은 string 값이 넘어오는 상황을 생각할 수 있다.

```ts
interface LightApiResponse {
  lightSwitchValue: boolean;
}

async function setLight() {
  const response = await fetch('/light');
  const result: LightApiResponse = await response.json();
  setLightSwitch(result.lightSwitchValue);
}
```

앞서 설명했듯이, 컴파일 한 이후에는 타입 정보가 모두 사라진다.  
이 점을 고려하여 외부 값에 대해서는 validation을 하는 등의 조치가 필요하다.

### 타입스크립트 타입으로는 함수를 오버로드할 수 없다.

java 등의 다른 언어에서는 함수 오버리이딩이 가능하여, 동일한 함수 이름으로 매개변수 타입 및 개수만 다르게 여러 버전의 함수를 정의하는 것이 가능하다.  
하지만 타입스크립트의 타입 정보는 런타임에 제거되기 때문에 함수를 오버라이딩 하는 것이 불가능하다.  

```ts
function add(a: number, b: number) { return a + b; }
      // ~~~ 중복된 함수 구현입니다.

function add(a: string, b: string) { return a + b; }
      // ~~~ 중복된 함수 구현입니다.
```

타입 수준에서 하나의 함수에 대해 여러 타입을 선언하는 것은 가능하다.  
하지만 해당 타입의 구현체는 오직 하나만 정의할 수 있다.

```ts
function add(a: number, b: number): number;
function add(a: string, b: string): string;

function add(a, b) {
  return a + b;
}
const three = add(1, 2); // number
const twelve = add('1', '2'); // string
```

### 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다.

타입스크립트의 타입은 런타임 시점에 제거되기 때문에, 런타임 성능에는 영향을 주지 않는다.  
자바스크립트로 변환하는데 소요되는 빌드 타임 오버헤드만 존재하며, 컴파일 성능도 최적화되어 있기 때문에 빠르게 컴파일 할 수 있다.  
만약 오버헤드가 커진다면 컴파일 과정에서 타입 체크를 하지 않도록 transpile only 설정을 킬 수 있다.

> 타입스크립트에서는 구버전의 런타임과 호환되기 위해 헬퍼 코드를 추가하여 오버헤드를 감수할지 선택할 수 있다.  
> 다만 이 경우 호환성과 성능 중 선택하는 언어 레벨의 문제인 것이지, 타입 자체와는 무관하다.

## 4. 구조적 타이핑에 익숙해지기

자바스크립트는 덕 타이핑 기반의 언어로, 함수의 매개변수에 적절히 값만 주어진다면 해당 값의 출처와 무관하게 정상 동작한다.  
타입스크립트는 이러한 동작 방식을 모델링하고 있어서, 명확히 타입 간 관계를 지정하지 않아도 매개변수 값을 사용할 수 있다.  
아래 예시에서 calculateLength는 Vector2D 타입을 받는 것으로 선언되어 있으나, Vector2D에 name을 추가한 NamedVector를 매개변수로 넘겨도 타입 체크를 통과한다.  
Vector2D와 NamedVector 사이에는 어떤 명시적인 관계도 설정되지 않았다.

```ts
interface Vector2D {
  x: number;
  y: number;
}

function calculateLength(v: Vector2D) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}

interface Vector3D {
  x: number;
  y: number;
  z: number;
}

const v: Vector3D = { x: 3, y: 4, z: 5 };
calculateLength(v); // 정상
```

이는 Vector3D가 x, y를 키로 가져서 Vector2D와 호환되기 때문이다.  
이러한 타입스크립트의 타이핑 방식을 구조적 타이핑이라고 한다.  
이로 인해 calculateLength가 Vector3D의 길이를 적절히 계산해줄 것으로 착각하고, 다음의 정규화 메서드를 구현하면 오작동하게 된다.

```ts
function normalize(v: Vector3D) {
    const length = calculateLength(v);
    return {
        x: v.x / length,
        y: v.y / length,
        z: v.z / length
    };
}
```

함수 호출 시 매개변수에 선언된 속성만 넘어올 것이라고 가정할 수 있다.  
하지만 타입스크립트의 타입은 열려 있기 때문에, 정의하지 않은 속성이 함께 넘어올 수 있다.  
이로 인해 다음과 같이 매개변수의 키를 순회해서 요소를 조회하는 경우, 요소의 타입이 any로 유추된다.

```ts
function calculateLengthL1(v: Vector3D) {
    let length = 0;
    for (const axis of Object.keys(v)) {
        const coord = v[axis];
                    //~~~~~~~  'string'은 'Vector3D'의 인덱스로 사용할 수 없기에
                    // 엘리먼트는 암시적으로 'any' 타입입니다.
        length += Math.abs(coord);
    }
    return length;
}
```

이는 Vector3D의 정의된 속성은 모두 number이지만, 다음과 같이 다른 타입의 값이 추가된 형태로 호출될 수 있기 때문이다.

```ts
const vec3D = {x: 3, y: 4, z: 1, address: '123 Broadway'};
calculateLengthL1(vec3D); // 정상, NaN을 반환
```

이런 상황에서는 속성을 순회하는 대신, 직접 모든 속성에 접근해서 더하는 식으로 구현해야 type safe하다.

```ts
function calculateLengthL1(v: Vector3D) {
  return Math.abs(v.x) + Math.abs(v.y) + Math.abs(v.z);
}
```

열려 있는 타입으로 인해 클래스 할당문에서도 타입 체크가 예상하지 못한 방식으로 동작할 수 있다.  
예를 들어 다음과 같이 변수를 클래스 C 타입으로 선언한 뒤 임의의 객체 리터럴을 할당해도 타입 체크는 정상적으로 통과한다.

```ts
class C {
    foo: string;
    constructor(foo: string) {
        this.foo = foo;
    }
}
const c = new C('instance of C');
const d: C = { foo: 'object literal' }; // 정상!
```

이는 변수 d도 string 타입의 foo 속성과, Object.prototype에 정의된 생성자를 가지기 때문이다.  
필요한 속성과 생성자가 모두 정의되어 있기 때문에 타입 체커는 문제가 없다고 판단한다.  
이로 인해 타입스크립트에서는 클래스 타입으로 변수를 선언하더라도, 변수가 해당하는 클래스 또는 서브클래스의 인스턴스임을 보장하지 않는다.

구조적 타이핑은 테스트 코드를 작성하는데 특히 유용하다.  
예를 들어 다음과 같이 쿼리를 실행하여 결과를 받아오는 메서드를 테스트해야 한다고 하자.

```ts
interface Author {
    first: string;
    last: string;
}

function getAuthors(database: PostgresDB): Author[] {
    const authorRows = database.runQuery('SELECT FIRST, LAST FROM AUTHORS');
    return authorRows.map(row => ({ first: row[0], last: row[1] }));
}
```

이 때 database 매개변수의 타입으로 실제 구현체인 PostgresDB를 지정하는 대신, 추상화된 인터페이스를 지정할 수 있다.

```ts
interface DB {
    runQuery: (sql: string) => any[];
}

function getAuthors(database: DB): Author[] {
    const authorRows = database.runQuery('SELECT FIRST, LAST FROM AUTHORS');
    return authorRows.map(row => ({ first: row[0], last: row[1] }));
}
```

이제 테스트 코드 직성 시에는 실제 DB 정보를 넘기는 대신, 인터페이스를 충족하는 임의의 객체를 정의하여 넘길 수 있다.  
모킹 라이브러리를 사용하지 않고도 db 객체를 모킹하는 효과를 얻을 수 있다.

```ts
test('getAuthors', () => {
    const authors = getAuthors({
        runQuery(sql: string) {
            return [['Toni', 'Morrison'], ['Maya', 'Angelou']];
        }
    });
    expect(authors).toEqual([
        { first: 'Toni', last: 'Morrison' },
        { first: 'Maya', last: 'Angelou' }
    ]);
});
```

## 5. any 타입 지양하기

타입스크립트에는 타입을 코드의 일부에만 적용하는 것이 가능하고, 언제든지 타입 체커를 해제하는 것도 가능하다.  
이러한 특성들이 가능한 것은 타입스크립트에 any 타입이 존재하기 때문이다.  
다음과 같이 any로 타입을 단언해버리면 타입 체크를 무조건 통과하게 된다.

```ts
  let age: number;

  age = '12';
//~~~ '"12"' 형식은 'number' 타입에 할당할 수 없습니다.
  age = '12' as any; // 정상
```

any를 사용하면 타입스크립트의 장점을 상당수 잃게 된다.  
때로는 any 타입이 불가피 할 때도 있지만, 그 경우에도 any의 위험성을 잘 이해하고 사용해야 한다.

### any 타입에는 타입 안전성이 없다.

위 예제에서 age는 number 타입으로 선언되었으나, '12'가 any 타입으로 단언되어 값으로 삽입되었다.  
이로 인해 age는 숫자 타입으로 가정되어 잘못된 타입 체크가 이루어지고, 런타임에서 예상하지 못한 방식으로 동작하게 된다.  
변수 하나가 any 타입으로 선언됨으로 인해 관련된 모든 코드들이 타입 안정성을 잃게 된다.

```ts
age += 1; // 런타임에 정상, age는 "121"
```

### any는 함수 시그니처를 무시한다.

함수를 정의할 때는 시그니처를 명시하여, 호출하는 쪽에서는 약속된 타입의 입력을 제공하고, 함수는 약속된 타입의 출력을 제공한다.  
하지만 any 타입을 사용하면 이러한 규칙을 무시할 수 있다.

```ts
function calculateAge(birthDate: Date): number {
  // ...
}
let birthDate: any = '1990-01-19';
calculateAge(birthDate); // 정상
```

자바스크립트는 string 타입의 값이 number 타입으로 동작하는 등 런타임에서 암시적인 타입 변환을 지원한다.  
이로 인해 문제가 감춰지고, 알 수 없는 부분에서 오류가 발생하게 된다.

### any 타입에는 언어 서비스가 적용되지 않는다.

특정 심볼에 타입이 있다면, 타입스크립트의 언어 서비스의 도움을 받을 수 있다.  
자동 완성, 도움말 제공, 이름 변경은 언어 서비스가 제공하는 대표적인 편의 기능이다.  
하지만 any 타입을 사용하는 부분에서는 이러한 기능들의 지원을 전혀 받을 수 없다.  
타입스크립트를 사용하는 핵심적인 이유 중 하나는 언어 서비스의 지원을 받아서 생산성을 향상시키는 것인데, any 타입을 사용하면 이것이 불가능하다.

### any 타입은 코드 리팩토링 시 버그를 감춘다.

매개변수의 타입 등을 변경하여 함수를 리팩터링할 때에는, 타입 정의와 함수 정의를 모두 수정해야 한다.  
하지만 any 타입으로 매개변수가 정의되어 있다면, 리팩토링 과정에서 타입 체크의 도움을 받을 수 없다.

예를 들어 특정 아이템을 선택하면 onSelectltem 콜백을 실행하는 컴포넌트를 정의해보자.  
타입 정의에서 콜백의 매개변수는 any 타입으로 정의되었고, 함수 정의에서도 any 타입으로 정의했다.

```ts
interface ComponentProps {
  onSelectItem: (item: any) => void;
}

function renderSelector(props: ComponentProps) { /* ... */ }

let selectedId: number = 0;

function handleSelectItem(item: any) {
  selectedId = item.id;
}
renderSelector({onSelectItem: handleSelectItem});
```

콜백의 매개변수로 id를 직접 받도록 하기 위해, 타입 정의에서 매개변수로 number 타입을 받도록 리팩토링 했다고 하자.  
이 때 id를 직접 받도록 함수의 정의를 함께 바꾸지 않았다면 런타임에서 오류가 발생하지만, 매개변수에 정의된 any 타입으로 인해 타입 체크에서 이를 걸러낼 수 없다.

```ts
interface ComponentProps {
  onSelectItem: (id: number) => void;
}
```

## any는 타입 설계를 감춰버린다.

React 등에서 사용되는 어플리케이션의 상태 객체에는 수많은 속성이 포함되며, 타입 정의 시 이들을 모두 지정해줘야 한다.  
any를 사용하면 이러한 수고를 덜 수 있지만, 이 경우 상태 객체의 설계를 감춰버려서 모든 코드를 들춰내야만 그 설계를 유추할 수 있게 된다.  
any 타입을 사용하면 설계가 불분명해짐을 명심하고, 가능한 모든 타입을 일일이 작성해줘야 한다.

## any는 타입시스템의 신뢰도를 떨어뜨린다.

any로 인해 지정한 타입과 런타임이 불일치하게 되면, 더 이상 타입 시스템을 신뢰할 수 없게 된다.  
개발 시 런타임의 타입과 지정한 타입을 모두 신경 써야 한다.
