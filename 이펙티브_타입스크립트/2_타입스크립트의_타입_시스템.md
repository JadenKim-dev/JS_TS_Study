## 6. 편집기를 사용하여 타입 시스템 탐색하기

타입스크립트를 설치하면 자바스크립트 변환을 위한 컴파일러 tsc와 함께, 단독으로 실행 가능한 언어 서비스인 tsserver를 제공 받는다.  
에디터에서 타입스크립트 언어 서비스를 사용하도록 설정하면 자동 완성, 명세, 검색, 리팩터링 등의 기능을 사용할 수 있다.  
언어 서비스를 통해 타입스크립트의 타입 시스템에 익숙해지고, 언제 타입 유추가 이루어지는지 이해하는데 도움을 받을 수 있다.

보통 편집기 상에서 심볼에 마우스를 올리면, 해당 심볼의 유추된 타입을 확인할 수 있다.  
예를 들어 다음과 같이 타입을 명시적으로 지정하지 않아도 num이 number로 유추되었음을 확인할 수 있다.

```ts
let num = 20
// let num: number
```

또한 함수의 타입도 자동으로 추론한다.  
다음 예시에서는 반환값의 타입이 자동으로 추론되었다.

```ts
function add(a: number, b: number) {
    return a + b;
}
// function add(a: number, b: number): number
```

이 때 만약 추론된 타입과 기대한 타입이 다르다면, 타입을 기대한 대로 명시한 뒤 어디서 문제가 발생하는지 확인해야 한다.  
타입 유추는 앞서 수행된 분기문 등에 의해 영향을 받기 때문에, 이들을 살펴보면서 타입 넓히기와 좁히기 등의 개념을 잡을 수 있다.  

```ts
function logMessage(message: string | null) {
    if (message) {
        // (parameter) message: string
        message
    }
}
```

또한 객체의 개별 속성들의 유추된 타입을 확인하는 것도 가능하다.

```ts
const foo = {
    // (property) x: number[]
    x: [1, 2, 3],
    bar: {
        name: 'Fred'
    }
};
```

연산자 체인의 중간에서 추론된 제네릭 타입을 확인하기 위해서, 중간에 호출된 메서드의 명세를 확인할 수 있다.  
다음의 예제에서는 split 결과의 제네릭 타입이 string임을 확인할 수 있다.

```ts
path.split('/').slice(1).join('/') 
//              -----
// (method) Array<string>.slice(start?: number, end?: number): string[]
```

언어 서비스에서 타입 오류로 판단하는 부분을 살펴보는 것도 도움이 된다.  

```ts
function getElement(elOrId: string | HTMLElement | null): HTMLElement {
  if (typeof elOrId === 'object') {
    return elOrId; 
//  ~~~~~~~~~~~~~~ 'HTMLElement | null' 형식은 'HTMLElement' 형식에 할당할 수 없습니다.
  } else if (elOrId === null) {
    return document.body;
  } else {
    const el = document.getElementById(elOrId);
    return el;
//  ~~~~~~~~~~ 'HTMLElement | null' 형식은 'HTMLElement' 형식에 할당할 수 없습니다.
  }
}
```

위 예제에서 getElement의 반환 타입은 HTMLElement로 정의되어 있다.  
첫번째 오류는 elOrId의 typeof를 object로 확인했다고 해도, typeof null도 마찬가지로 object이기 때문에 발생했다.  
또한 두번째 오류는 document.getElementById 가 null을 반환할 수 있기 때문에 발생했다.  
두 경우 모두 null 체크를 해서 필요한 경우 예외를 던지도록 구현해야 한다.

또한 타입스크립트 언어 서비스를 이용하면 정의로 이동(Go to Definition)하는 기능을 에디터에서 사용할 수 있다.  
예를 들어 다음과 같이 fetch를 사용하는 코드에서 정의로 이동 기능을 사용해서 fetch의 타입 선언으로 이동할 수 있다.

```ts
const response = fetch('...')

// lib.dom.d.ts
declare function fetch(
    input: RequestInfo, init?: RequestInit
): Promise<Response>
```

동일한 방식으로 RequestInfo, RequestInit의 타입 선언으로 이동할 수 있다.  
이를 통해 라이브러리가 어떻게 설계되었는지를 살펴볼 수 있어서, 오류를 찾아내는데 도움을 받을 수 있다.

## 7. 타입이 값들의 집합이라고 생각하기

타입스크립트의 타입은 특정 변수에 할당할 수 있는 값들의 집합이라고 할 수 있다.  
예를 들어 number 타입은 모든 숫자값의 집합으로 이해할 수 있다.  
strictNullChecks는 null과 undefined를 모든 타입의 집합에 포함시킬지를 결정하는 값으로 이해할 수 있다.

never 타입은 아무 값도 포함하지 않는 공집합이며, 따라서 어떤 값도 never 타입의 변수에 할당할 수 없다.

```ts
const x: never = 12;
   // ~ '12' 형식은 'never' 형식에 할당할 수 없습니다.
```

그 다음으로 작은 집합은 하나의 값만 포함하는 리터럴 타입(유닛 타입)이다.  
두 개 이상의 값을 할당 가능하게 하려면 유니온 연산자(|)로 묶어서 합집합으로 만들면 된다.  


