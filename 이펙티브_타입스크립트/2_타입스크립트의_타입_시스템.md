## 6. 편집기를 사용하여 타입 시스템 탐색하기

타입스크립트를 설치하면 자바스크립트 변환을 위한 컴파일러 tsc와 함께, 단독으로 실행 가능한 언어 서비스인 tsserver를 제공 받는다.  
에디터에서 타입스크립트 언어 서비스를 사용하도록 설정하면 자동 완성, 명세, 검색, 리팩터링 등의 기능을 사용할 수 있다.  
언어 서비스를 통해 타입스크립트의 타입 시스템에 익숙해지고, 언제 타입 유추가 이루어지는지 이해하는데 도움을 받을 수 있다.

보통 편집기 상에서 심볼에 마우스를 올리면, 해당 심볼의 유추된 타입을 확인할 수 있다.  
예를 들어 다음과 같이 타입을 명시적으로 지정하지 않아도 num이 number로 유추되었음을 확인할 수 있다.

```ts
let num = 20
// let num: number
```

또한 함수의 타입도 자동으로 추론한다.  
다음 예시에서는 반환값의 타입이 자동으로 추론되었다.

```ts
function add(a: number, b: number) {
    return a + b;
}
// function add(a: number, b: number): number
```

이 때 만약 추론된 타입과 기대한 타입이 다르다면, 타입을 기대한 대로 명시한 뒤 어디서 문제가 발생하는지 확인해야 한다.  
타입 유추는 앞서 수행된 분기문 등에 의해 영향을 받기 때문에, 이들을 살펴보면서 타입 넓히기와 좁히기 등의 개념을 잡을 수 있다.  

```ts
function logMessage(message: string | null) {
    if (message) {
        // (parameter) message: string
        message
    }
}
```

또한 객체의 개별 속성들의 유추된 타입을 확인하는 것도 가능하다.

```ts
const foo = {
    // (property) x: number[]
    x: [1, 2, 3],
    bar: {
        name: 'Fred'
    }
};
```

연산자 체인의 중간에서 추론된 제네릭 타입을 확인하기 위해서, 중간에 호출된 메서드의 명세를 확인할 수 있다.  
다음의 예제에서는 split 결과의 제네릭 타입이 string임을 확인할 수 있다.

```ts
path.split('/').slice(1).join('/') 
//              -----
// (method) Array<string>.slice(start?: number, end?: number): string[]
```

언어 서비스에서 타입 오류로 판단하는 부분을 살펴보는 것도 도움이 된다.  

```ts
function getElement(elOrId: string | HTMLElement | null): HTMLElement {
  if (typeof elOrId === 'object') {
    return elOrId; 
//  ~~~~~~~~~~~~~~ 'HTMLElement | null' 형식은 'HTMLElement' 형식에 할당할 수 없습니다.
  } else if (elOrId === null) {
    return document.body;
  } else {
    const el = document.getElementById(elOrId);
    return el;
//  ~~~~~~~~~~ 'HTMLElement | null' 형식은 'HTMLElement' 형식에 할당할 수 없습니다.
  }
}
```

위 예제에서 getElement의 반환 타입은 HTMLElement로 정의되어 있다.  
첫번째 오류는 elOrId의 typeof를 object로 확인했다고 해도, typeof null도 마찬가지로 object이기 때문에 발생했다.  
또한 두번째 오류는 document.getElementById 가 null을 반환할 수 있기 때문에 발생했다.  
두 경우 모두 null 체크를 해서 필요한 경우 예외를 던지도록 구현해야 한다.










