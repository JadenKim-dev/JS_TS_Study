## 6. 편집기를 사용하여 타입 시스템 탐색하기

타입스크립트를 설치하면 자바스크립트 변환을 위한 컴파일러 tsc와 함께, 단독으로 실행 가능한 언어 서비스인 tsserver를 제공 받는다.  
에디터에서 타입스크립트 언어 서비스를 사용하도록 설정하면 자동 완성, 명세, 검색, 리팩터링 등의 기능을 사용할 수 있다.  
언어 서비스를 통해 타입스크립트의 타입 시스템에 익숙해지고, 언제 타입 유추가 이루어지는지 이해하는데 도움을 받을 수 있다.

### 추론된 타입을 확인하기

보통 편집기 상에서 심볼에 마우스를 올리면, 해당 심볼의 유추된 타입을 확인할 수 있다.  
다음의 예제에서도 num 변수의 타입이 명시적으로 지정되지 않았지만, 할당된 값을 바탕으로 number로 유추되었다.

```ts
let num = 20
// let num: number
```

함수의 타입도 자동으로 추론된다.  
다음 예시에서는 add 함수의 반환값 타입이 로직을 바탕으로 자동 추론되었다.

```ts
function add(a: number, b: number) {
  return a + b;
}
// function add(a: number, b: number): number
```

이 때 만약 추론된 타입과 기대한 타입이 다르다면, 타입을 기대한 대로 명시한 뒤 어디서 문제가 발생하는지 확인해야 한다.  
타입 유추는 앞서 수행한 분기문 등의 영향을 받는데, 이들을 살펴보면서 타입 넓히기와 좁히기 등의 개념을 잡을 수 있다.  
아래 예시에서도 분기문에서 매개 변수 message에 대한 null 체크를 수행함에 따라 string 으로 타입이 좁혀졌다.

```ts
function logMessage(message: string | null) {
  if (message) {
    // (parameter) message: string
    message
  }
}
```

또한 객체의 개별 속성들의 유추된 타입을 확인하는 것도 가능하다.

```ts
const foo = {
    // (property) x: number[]
    x: [1, 2, 3],
    bar: {
        name: 'Fred'
    }
};
```

연산자 체인의 중간 반환값의 제네릭 타입을 확인하기 위해서, 중간에 호출된 메서드의 명세를 확인할 수 있다.  
다음의 예제에서는 split 결과의 제네릭 타입이 string임을 확인할 수 있다.

```ts
path.split('/').slice(1).join('/') 
//              -----
// (method) Array<string>.slice(start?: number, end?: number): string[]
```

### 타입 오류 확인하기

언어 서비스에서 타입 오류로 판단하는 부분을 살펴보는 것도 타입 시스템을 이해하는데 도움이 된다.  

아래 예제에서 getElement의 반환 타입은 HTMLElement로 정의되어 있다.  
첫번째 오류는 elOrId의 타입을 object로 확인했다고 해도, null의 typeof 결과도 object이기 때문에 발생했다.  
두번째 오류는 document.getElementById 가 null을 반환할 수 있기 때문에 발생했다.  
두 경우 모두 null 체크를 해서 필요한 경우 예외를 던지도록 구현해야 한다.

```ts
function getElement(elOrId: string | HTMLElement | null): HTMLElement {
  if (typeof elOrId === 'object') {
    return elOrId; 
//  ~~~~~~~~~~~~~~ 'HTMLElement | null' 형식은 'HTMLElement' 형식에 할당할 수 없습니다.
  } else if (elOrId === null) {
    return document.body;
  } else {
    const el = document.getElementById(elOrId);
    return el;
//  ~~~~~~~~~~ 'HTMLElement | null' 형식은 'HTMLElement' 형식에 할당할 수 없습니다.
  }
}
```

또한 타입스크립트 언어 서비스를 이용하면 정의로 이동(Go to Definition)하는 기능을 에디터에서 사용할 수 있다.  
예를 들어 다음과 같이 fetch를 사용하는 코드에서 정의로 이동 기능을 사용해서 fetch의 타입 선언으로 이동할 수 있다.

```ts
const response = fetch('...')

// lib.dom.d.ts
declare function fetch(
    input: RequestInfo, init?: RequestInit
): Promise<Response>
```

동일한 방식으로 RequestInfo, RequestInit의 타입 선언으로 이동할 수 있다.  
이를 통해 라이브러리가 어떻게 설계되었는지를 살펴보고, 어디서 오류가 발생했는지를 디버깅할 수 있다.

## 7. 타입이 값들의 집합이라고 생각하기

타입스크립트의 타입은 특정 변수에 할당할 수 있는 값들의 집합으로 볼 수 있다.  
예를 들어 number 타입은 모든 숫자값의 집합으로 이해할 수 있다.  
strictNullChecks는 null과 undefined를 모든 타입의 집합에 포함시킬지를 결정하는 설정으로 이해할 수 있다.

### 타입과 집합

never 타입은 아무 값도 포함하지 않는 공집합이며, 따라서 어떤 값도 never 타입의 변수에 할당할 수 없다.

```ts
const x: never = 12;
   // ~ '12' 형식은 'never' 형식에 할당할 수 없습니다.
```

그 다음으로 작은 집합은 하나의 값만 포함하는 리터럴 타입(유닛 타입)이다.  
두 개 이상의 값을 할당 가능하게 하려면 유니온 연산자(|)로 묶어서 합집합으로 만들면 된다.  

```ts
type A = 'A';
type B = 'B';
type Twelve = 12;

type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
```

타입 오류에서는 `~~ 형식을 ~~ 형식에 할당할 수 없습니다.` 와 같은 메시지를 자주 확인할 수 있다.  
집합 관점에서 타입 체커는 한 집합이 다른 집합의 부분 집합에 해당하는지를 체크한다.

```ts
const ab: AB = Math.random() < 0.5 ? 'A' : 'B'; // 정상, {"A", "B"}는 {"A", "B"}의 부분 집합입니다.
const ab12: AB12 = ab; // 정상, {"A", "B"}는 {"A", "B", 12}의 부분 집합입니다.

declare let twelve: AB12;
const back: AB = twelve; 
    //~~~~ 'AB12' 형식은 'AB' 형식에 할당할 수 없습니다.
    //     '12' 형식은 'AB' 형식에 할당할 수 없습니다.
```

위에서 다룬 타입들은 원소의 개수가 한정되어 있지만, 일반적으로 다루는 타입들은 값의 개수가 무한대이다.  
일반적인 타입들은 다음과 같이 무수히 많은 원소를 일일이 유니온해서 추가한 것으로 이해할 수 있다.

```ts
type Int = 1 | 2 | 3 | 4 | 5 // | ...
```

### 집합으로 이해하는 구조적 타이핑과 타입 연산(&, |)

이제 이전에 살펴봤던 구조적 타이핑을 다시 한 번 살펴보자.  
다음과 같이 id 속성을 가진 Identified 인터페이스를 정의했다면, 해당 타입에는 id 외의 다른 잉여 속성들을 함께 가지고 있는 객체들도 할당이 가능하다.  
즉 string 타입의 id 프로퍼티만 가지고 있으면 어떤 타입이든 Identified의 부분집합이 되는 것이다.

```ts
interface Identified {
  id: string;
}
```

이러한 개념을 바탕으로 & 연산자를 살펴보자.  
다음의 예시에서는 Person과 Lifespan을 & 연산자로 묶어서 PersonSpan 타입을 정의하고 있다.

```ts
interface Person {
  name: string;
}

interface Lifespan {
  birth: Date;
  death?: Date;
}

type PersonSpan = Person & Lifespan;
```

이 때 타입 연산자는 타입의 속성들이 아닌, 타입의 범위에 적용됨을 기억해야 한다.  
Person과 Lifespan은 자신이 정의하지 않은 속성을 함께 가진 값들도 범위에 포함한다.  
따라서 이 둘의 교집합은 각 타입에서 정의한 속성들을 모두 가지고 있는 값들로 구성된다.

```ts
const ps: PersonSpan = {
    name: 'Alan Turing',
    birth: new Date('1912/06/23'),
    death: new Date('1954/06/07'),
};
```

keyof를 통해 특정 타입에서 정의한 속성의 목록을 추출할 수 있다.  
`&` 연산을 하면 두 타입의 키들이 합쳐지고, `|` 연산을 하면 공통으로 기지고 있는 키들만 남게 된다.  
Person과 Lifespan의 공통 키는 없기 때문에, `|` 연산을 한 뒤 keyof를 하면 never 타입이 된다.

```ts
type T = keyof (Person & Lifespan); // 'name' | 'birth' | 'death'
type K = keyof (Person | Lifespan); // never
```

해당 개념을 등식으로 표현하면 다음과 같다.  
& 연산을 하면 두 타입의 키가 합쳐지고, | 연산을 하먄 공통 키만 남게 된다.

```ts
keyof (A & B) = (keyof A) | (keyof B)
keyof (A | B) = (keyof A) & (keyof B)
```

### 집합으로 이해하는 extends

extends 키워드도 타입 간 관계를 나타낼 때 많이 사용한다.  
집합의 관점에서 extends는 해당 타입이 다른 타입의 부분집합임을 선언하는 것이라고 이해할 수 있다.  
다음 예시에서 PersonSpan는 Person의 모든 키를 가지면서 자신의 키를 추가로 가지기 때문에 Person의 부분집합이 된다.

```ts
interface Person {
  name: string;
}
interface PersonSpan extends Person {
  birth: Date;
  death?: Date;
}
```

타입스크립트에서는 extends한 타입을 서브타입이라고 말한다.  
아래의 예시에서 Vector3D는 Vector2D의 서브타입이고, Vector2D는 Vector1D의 서브타입이다.  
extends는 타입 간 상속 관계를 맺게 하는 것이기도 하지만, 타입스크립트에서는 부분 집합 관계를 설정하는 것으로 이해하는게 더 유용하다.  
예시에서 Vector3D는 Vector2D의 부분 집합이고, Vector2D는 Vector1D의 부분집합이다.

```ts
interface Vector1D { x: number; }
interface Vector2D extends Vector1D { y: number; }
interface Vector3D extends Vector2D { z: rumiber; }
```

extends는 제네릭의 한정자로도 쓰이며, 이 때에는 제네릭을 특정 집합의 부분집합으로 제한하는 것으로 이해할 수 있다.

```ts
function getKey<K extends string>(val: any, key: K) {
  // ...
}
```

위 예시에서 제네릭 타입 K가 string 타입을 상속한다는 의미로 해석하면 잘 이해가 되지 않는다.  
하지만 K가 string의 부분집합이라는 의미로 해석하면, 이에 포함되는 string 리터럴 타입, 리터럴 타입의 유니온 등이 포함될 수 있음을 이해할 수 있다.

```ts
getKey({}, 'x');
getKey({}, Math.random() < 0.5 ? 'a' : 'b');
getKey({}, document.title);
getKey({}, 12); // 오류: '12' 형식의 인수는 'string' 형식의 매개변수에 할당될 수 없습니다.
```

집합의 개념을 이용하면 객체의 키 타입을 반환하는 keyof 연산자를 더 잘 이해할 수 있다.  
다음 예시에서 sortBy 메서드의 제네릭 K는 T의 키 타입의 부분집합으로 제한되었다.  
이에 따라 제네릭 T로 Point 타입을 사용하면 K에는 `'x' | 'y'` 유니온 타입의 부분집합만 할당 가능하다.  
다른 임의의 문자열은 해당 유니온 타입의 부분집합이 아니므로 할당될 수 없다.

```ts
function sortBy<K extends keyof T, T>(vals: T[], key: K): T[] {
  // ...
}

interface Point {
  x: number;
  y: number;
}

const pts: Point[] = [{x: 1, y: 1}, {x: 2, y: 0}];
sortBy(pts, 'x');
sortBy(pts, 'y');
sortBy(pts, Math.random() < 0.5 ? 'x' : 'y');
sortBy(pts, 'z'); // 오류, 'z' 형식의 인수는 '"x" | "y"' 형식의 매개변수에 할당될 수 없습니다
```

엄격한 상속 관계가 아닌 타입은 집합 관점에서 더 잘 설명 될 수 있다.  
예를 들어 `sring | number`와 `string | Date` 사이의 인터섹션은 string이다.  
string이 이들을 상속했다는 식으로는 설명이 어렵지만, string이 두 타입의 부분집합이리는 점은 쉽게 이해할 수 있다.

### 집합으로 이해하는 튜플

배열과 튜플의 관계에 대해서도 살펴보자.  
배열을 변수에 할당하면 해당 변수의 타입은 배열로 유추된다.  
이 때 배열은 튜플의 부분집합이 아니기 때문에, 튜플 타입으로 선언한 변수에는 배열 변수를 할당할 수 없다.  
하지만 반대로 튜풀은 배열의 부분집합이기 때문에, 튜플 타입의 변수를 배열 변수에 할당하는 것은 가능하다.

```ts
const list = [1, 2]; // 타입은 number[]
const tuple: [number, number] = list;
//    ~~~~~ 'number[]' 타입은 '[number, number]' 타입의 0, 1 속성에 할당할 수 없습니다.

const tuple2: [number, number] = [1, 2];
const list2: number[] = tuple;
```

이번엔 튜플 간의 관계를 살펴보자.  
숫자 세 개로 이루어진 triple 튜플은 값 두 개로 이루어진 double 튜플에 할당 가능할 것으로 생각할 수 있다.  
하지만 이는 불가능하며, 그 이유는 타입스크립트가 튜플을 모델링할 때 배열의 length 값을 함께 반영했기 때문이다.  
예를 들어 double 튜플 타입은 `{0: number, 1: number, length: 2}` 로 모델링 되어있다.  
이는 각 길이의 튜플 타입을 구분하기 위한 합리적인 모델링이다.

```ts
const triple: [number, number, number] = [1, 2, 3];
const double: [number, number] = triple;
// [number, number, number] 형식은 [number, number] 형식에 할당할 수 없습니다.
// 'length' 속성의 형식이 호환되지 않습니다. '3' 형식은 '2' 형식에 할당할 수 없습니다.
```

### 집합으로써의 타입 주의 사항

타입은 값의 집합이기 때문에, 동일한 값의 집합을 가지는 타입은 동일한 타입이며, 따라서 중복 정의할 필요가 없다.  

또한 타입에서 특정 값을 배제하는 식으로 타입을 정의하는 것은 불가능하다.  
예를 들어 정수 타입을 정의하거나, 0을 제외한 number로 타입을 정의하는 것은 불가능하다.  
Exclude 타입 연산은 그 결과가 일반적인 타입에 해당할 때에만 유효하게 동작한다.

```ts
type T = Exclude<string | Date, string | number>; // Date
type NonZeroNums = Exclude<number, 0>; // number

const num: NonZeroNums = 0;  // 정상
```

### 집합 개념과 타입 매칭

- never = 공집합
- 리터럴 타입 = 원소가 1개인 집합
- 값이 T에 할당 가능 = 값이 T의 원소
- T1이 T2에 할당 가능 = T1이 T2의 부분 집합
- T1이 T2를 상속 = T1이 T2의 부분 집합
- T1 | T2 = T1과 T2의 합집합
- T1 & T2 = T1과 T2의 교집합
- unknown = 전체(universal) 집합

## 8. 타입 공간과 값 공간의 심벌 구분하기

### 타입과 값 심벌 구분하기

타입스크립트의 심벌은 타입 공간과 값 공간에 존재할 수 있다.  
두 공간에 동일한 이름의 심볼이 존재할 수도 있으며, 이 경우 상황에 따라 값 또는 타입으로 다르게 사용된다.  
예를 들어 다음의 예제에서 Cylinder는 타입 공간과 값 공간 모두에 정의되어 있으나, 서로 아무런 관계도 가지지 않는다.

```ts
interface Cylinder {
  radius: number;
  height: number;
}
const Cylinder = (radius: number, height: number) => ({ radius, height });
```

이러한 점은 혼란을 야기하기도 한다.  
다음의 예제의 원래 의도는 shape의 타입이 Cylinder 인지를 확인하는 것이다.  
하지만 런타임 연산자인 instanceof를 사용함에 따라 값 Cylinder가 참조되었고, Cylinder는 생성자가 아니므로 instanceof를 사용해도 정상적으로 타입 좁히기가 되지 않는다.

```ts
function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    console.log(shape.radius);
                    //~~~~~~ {} 형식에 'radius' 속성이 없습니다.
  }
}
```

이와 같이 심벌이 값인지 타입인지는 전체 맥락을 살펴봐야 알 수 있다.  
일반적으로 `type` 이나 `interface` 뒤에 나오는 심벌은 타입으로, `const`나 `let` 뒤에 나오는 심벌은 값으로 판단하면 된다.  

```ts
type T1 = 'string literal';
type T2 = 123;
const v1 = 'string literal';
const v2 = 123;
```

타입스크립트에서 타입과 값은 번갈아 나오는 경우가 많다.  
타입 선언(:) 또는 단언문(as) 뒤에 나오는 심벌은 타입이고, 할당(=) 뒤에 나오는 것은 값이다.

```ts
interface Person {
  first: string;
  last: string;
}

const p: Person = { first: 'Jane', last: 'Jacobs' };
//    -           --------------------------------- 값
//       ------                                     타입

function email(p: Person, subject: string, body: string): Response {
//       ----- -          -------          ----                    값
//                ------           ------        ------   -------- 타입
  // ...
}
```

class와 enum은 상황에 따라 타입과 값으로 모두 사용될 수 있다.  
클래스가 타입으로 사용될 때에는 속성, 메서드를 포함하는 인스턴스의 타입을 참조하고, 값으로 사용될 때에는 생성자가 참조된다.

```ts
class Cylinder {
  radius = 1;
  height = 1;
}

function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape // 타입 Cylinder
    shape.radius // 타입 number
  }
}
```

### 타입 또는 값에 대한 typeof 연산자

typeof는 값과 타입 중 어디에 쓰이는지에 따라서 다르게 동작하는 연산자이다.

타입에 쓰일 경우에는 값을 읽어서 타입을 반환하는 식으로 동작한다.  
이를 통해 타입을 type 구문으로 재정의하여 이름을 붙이거나, 객체 정의에서 타입을 추출하는 것이 가능하다.

이와 달리 값에 쓰일 경우에는 자바스크립트 런타임 타입을 문자열로 반환하는 식으로 동작한다.  
자바스크립트 런타임에는 6가지 타입만 존재(string, number, boolean, undefined, object, function)하기 때문에 타입스크립트 타입보다 훨씬 단순하게 동작한다.

```ts
type T1 = typeof p; // 타입은 Person
type T2 = typeof getResponse; // 타입은 (p: Person, subject: string, body: string) => Response
const v1 = typeof p; // 값은 "object"
const v2 = typeof email; // 값은 "function"
```

클래스에 typeof를 적용할 때에는 클래스의 값인 생성자에 적용하여, 클래스의 타입을 추출하게 된다.  
이 때 typeof가 값의 맥락으로 쓰일 때에는 생성자의 런타임 타입에 맞게 'function' 문자열이 반환된다.  
이와 달리 타입의 맥락으로 쓰일 때에는 클래스의 생성자 타입이 추출되어 반환된다.  
생성자 타입은 InstanceType의 제네릭으로 넘겨서 인스턴스 타입으로 전환할 수 있다.

```ts
const v = typeof Cylinder; // 값이 "function"
type T = typeof Cylinder; // 타입이 typeof Cylinder

declare let fn: T;
const c = new fn(); // 타입이 Cylinder

type C = InstanceType<T>; // 타입이 Cylinder
```

### 타입에 대한 속성 접근자([])

속성 접근자 []는 타입에도 사용이 가능하여, 속성의 타입에 접근하는데 사용된다.  
다만 타입의 속성에 접근할 때에는 점 표기법은 사용할 수 없으며, 반드시 Person['first'] 와 같이 접근해야 한다.  
아래의 예시에서 Person['first']는 타입 맥락에 쓰였기 때문에 타입으로 해석되어, first 속성의 타입이 변수에 적용된다.

```ts
const first: Person['first'] = p['first'];
//    -----                    ---------- 값
//           ---------------              타입
```

이 때 인덱스 위치에는 유니온 타입이나 기본형 타입을 포함하여 어떤 타입이든 사용할 수 있다.

```ts
type PersonEl = Person['first' | 'last']; // 타입은 string
type Tuple = [string, number, Date];
type TupleEl = Tuple[number]; // 타입은 string | number | Date
```

### 각 공간에서 다른 의미를 가지는 코드 패턴

타입 공간과 값 공간에서 다른 의미를 가지는 코드 패턴들이 있다.

- 값 this / 메서드 체인 구현에 사용하는 다형성 this
- &, | 연산
- const / as const
- in 루프 / 매핑된 타입

이 외에도 타입 공간과 값 공간을 혼동할 경우 문제가 자주 발생하는데, 구조 분해 할당의 경우가 대표적이다.  
아래 예시에서는 구조 분해를 수행하는 값 공간에 타입을 지정하는 식으로 정의하여 타입 에러가 발생했다.  
구조 분해한 값을 이용하여 바인딩 변수인 Person, string을 정의하는 것으로 인식된다.

```ts
function email({
  person: Person, // 바인딩 요소 'Person'에 암시적으로 'any' 형식이 있습니다.
  subject: string, // 'string' 식별자가 중복되었습니다. 바인딩 요소 'string'에 암시적으로 'any' 형식이 있습니다.
  body: string, // 'string' 식별자가 중복되었습니다. 바인딩 요소 'string'에 암시적으로 'any' 형식이 있습니다
}) { /* ... */ }
```

구조 분해 시에는 다음과 같이 타입 공간을 확실히 구분해서 각 바인딩 요소의 타입을 정의해야 한다.

```ts
function email(
  {person, subject, body}: {person: Person, subject: string, body: string}
) {
  // ...
}
```

## 9. 타입 단언보다는 타입 선언을 사용하기

변수에 타입을 지정할 때에는 다음과 같이 타입 선언을 하거나 타입 단언을 할 수 있다.

```ts
interface Person { name: string };

const alice: Person = { name: 'Alice' };  // 타입 선언
const bob = { name: 'Bob' } as Person;  // 타입 단언
```

이 때 타입 선언을 사용하면 변수에 할당하는 값이 타입에 맞는지 검사한다.  
이와 달리 타입 단언을 사용하면 타입 체크를 무시하고 변수에 값을 할당한다.

```ts
const alice: Person = {}; // Person 유형에 필요한 'name' 속성이 '{}' 유형에 없습니다
const bob = {} as Person; // 정상
```

객체 리터럴에 잉여 속성을 추가할 때에도 타입 단언을 사용하면 타입 체크를 무시하게 된다.  
타입 단언이 반드시 필요한 게 아니라면 안정성 체크가 가능한 타입 선언을 사용하는게 좋다.

```ts
const alice: Person = {
  name: 'Alice',
  occupation: 'TypeScript developer' 
  // 개체 리터럴은 알려진 속성만 지정할 수 있으며 'Person' 형식에 'occupation'이 없습니다.
};

const bob = {
  name: 'Bob',
  occupation: 'JavaScript developer'
} as Person; // 오류 없음
```

### 화살표 함수에서의 타입 선언

화살표 함수를 사용하면 추론된 타입이 모호해지는 경우가 많다.  
예를 들어 다음과 같이 이름의 배열에 map을 사용해서 Person의 배열로 변경하고 싶다고 하자.

```ts
const people = ['alice', 'bob', 'jan'].map(name => ({ name }));
// 결과는 { name: string; }[]
```

이 때 타입 단언을 사용해서 타입을 명시할 수도 있으나, 이 경우 타입 체크가 되지 않아서 잘못된 런타임 타입이 전달 될 수 있다.

```ts
const people = ['alice', 'bob', 'jan'] .map(name => ({} as Person)); // 오류 없음
```

다음과 같이 화살표 함수에 직접 타입을 선언하고, 최종 결과 변수의 타입도 함께 선언해야 타입 안정성을 지킬 수 있다.  
이렇게 하면 할당문의 유효성까지 함께 검사할 수 있다.

```ts
const people: Person[] = ['alice', 'bob', 'jan'].map(
  (name): Person => ({name})
);
```

### 타입 단언문이 필요한 경우

타입 단언문은 반드시 필요한 경우에만 사용해야 하는데, 보통 타입 체커보다 개발자가 더 많은 정보를 알고 있는 상황에서 쓸 수 있다.  
대표적인 예시가 DOM 엘리먼트를 사용하는 경우이다.  
타입 체커는 DOM에 접근할 수 없기 때문에 querySelector 등의 결과가 어떤 엘리먼트인지 알 수 없다.  
따라서 구체적인 엘리먼트 타입을 사용하기 위해서는 타입 단언이 불가피하다.

```ts
document.querySelector('#myButton').addEventListener('click', e => {
  e.currentTarget // EventTarget
  const button = e.currentTarget as HTMLButtonElement;
  button // HTMLButtonElement
});
```

다음과 같은 !를 이용한 단언문도 동일한 주의가 필요하다.  
해당 값이 null이 아니라는 확실한 추가 정보를 가졌을 때에만 !를 이용한 타입 단언을 사용해야 한다.

```ts
const elNull = document.getElementById('foo'); // 타입은 HIMLElement | null
const el = document.getElementById('foo')!; // 타입은 HTMLElement
```

또한 타입 단언을 사용한다고 해도 관련이 없는 임의의 타입 간에도 변환할 수 있는 것은 아니다.
변환하려는 타입이 현재 타입의 부분집합인 경우이만 타입 단언을 수행할 수 있다.  
지금까지 살펴본 타입 단언도 EventTarget을 ButtonElement로 변경하거나, `HTMLElement | null`을 `HTMLElement`로 변환하는 등 부분 집합으로의 단언만 수행했다.  
관련이 없는 타입으로 단언하면 다음과 같이 unknown으로 변환 후 단언하라는 에러 메시지가 확인된다.  
모든 타입은 unknown의 서브타입이기 때문에 unknown은 어떤 타입으로든 단언할 수 있다.

```ts
interface Person { name: string; }
const body = document.body;
const el = body as Person;
// 'HTMLElement' 형식을 'Person' 형식으로 변환하는 것은 형식이 다른 형식과 충분히 겹치지 않기 때문에 실수일 수 있습니다.
// 이것이 의도적인 경우에는 먼저 식을 'unknown'으로 변환하십시오.
```

## 10. 객체 래퍼 타입 피하기

자바스크립트의 string, number, boolean 등의 기본형들은 불변이며 메서드를 가지지 않는다는 특성을 가진디.  
다만 아래와 같이 string을 사용할 때에는 마치 메서드를 가지고 있는 것처럼 사용할 수 있다.

```ts
> 'primitive'.charAt(3)
"m"
```

자바스크립트에서는 기본형과 객체 타입을 자유롭게 변환해서 사용하는 것이 가눙하다.  
string 기본형과 관련된 메서드들은 String 객체에 정의되어 있다.  
string의 메서드를 호출 시 js에서는 String 객체로 기본형을 래핑하고 메서드를 호출한 뒤, 객체를 다시 버린다.  
이 점 덕분에 기본형 값에 메서드를 호출하는 것이 가능하다.

String 프로토타입의 메서드를 조작하는 식으로 몽키 패치하면 내부적인 동작을 확인할 수 있다.  
출력 결과 메서드 내부의 this는 래퍼 타입인 String을 바라보고 있다.

```ts
const originateharAt = String.prototype.charAt;
String.prototype.charAt = function(pos) {
  console.log(this, typeof this, pos);
  return originalCharAt.call(this, pos);
}；
console.log('primitive'.charAt(3));

// 출력
[String: 'primitive'] 'object' 3
m
```

String 객체의 인스턴스를 직접 생성하면 기본형 string 처럼 사용하는 것이 가능하다.  
하지만 객체와 기본형은 몇몇 동작에서 다르게 동작하기 때문에 혼란스러울 수 있다.  
예를 들어 String 객체는 값과 관련 없어 자기 자신과만 동일하다.

```ts
> "hello" === new String("hello")
false
> new String("hello") === new String("hello")
false
```

또한 string 기본형의 속성에는 값을 할당할 수 없다.  
아래 예시에서 language 속성은 일시적으로 변환된 string 객체에 적용되었고, 그 직후에 버려져서 확인이 불가능하다.

```ts
> x = "hello"
> x.language = 'English'
'English'
> x.language
undefined
```

다른 기본형들에도 동일하게 Number, Boolean, Symbol, BigInt 객체 래퍼 타입이 존재한다.  
타입스크립트에서는 기본형과 객체 래퍼 타입을 별도로 모델링하기 때문에 이들을 혼동하지 않도록 주의해야 한다.  
예를 들어 String 객체 타입에는 string 기본형 타입을 할당할 수 없지만, 그 반대는 가능하다.  
이는 모단 타입 선언을 래퍼 객체 타입으로 하면 문제가 없다는 의미이기는 하지만, 굳이 그럴 필요 없이 기본형 타입으로 정의하는게 적절하다.

```ts
function getStringLen(foo: String) {
  return foo.length;
}
getStringLen("hello"); // 정상
getStringLen(new String("hello")); // 정상

function getStringLen2(foo: string) {
  return foo.length;
}
getStringLen2("hello"); // 정상
getStringLen2(new String("hello"));
//            ~~~~~~~~~~~~~~~~~~~
// 'String' 형식의 인수는 'string' 형식의 매개변수에 할당될 수 없습니다.
// 'string'은 기본 개체이지만 'String'은 래퍼 개체입니다. 가능한 경우 'string'을 사용하세요.
```

추가로, BigInt, Symbol은 new 키워드 없이 호출할 경우 기본형 값을 반환한다.  
따라서 이 경우에도 기본형 타입인 bigint, symbol을 사용해서 타이핑하면 된다.  

```ts
typeof BigInt（1234） // "bigint"  
typeof Symbol('sym') // "symbol"  
```

## 잉여 속성 체크의 한계 인지하기

앞서 살펴봤듯이 타입이 명시된 변수에 객체 리터럴을 할당할 때에는 잉여 속성 체크가 이루어져, 명시되지 않은 속성이 포함될 경우 타입 에러가 발생한다.

```ts
interface Room {
  numDoors: number;
  ceilingHeightFt: number;
}

const r: Room = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: 'present',
  // 객체 리터럴은 알려진 속성만 지정할 수 있으며 'Room' 형식에 'elephant'이(가) 없습니다.
};
```

하지만 구조적 타이핑 관점에서 보면, 잉여 속성이 있더라도 부분집합을 구성하는 타입이라면 할당이 가능해야 한다.  
실제로 객체 리터럴을 직접 할당하지 않고 변수에 담았다가 할당하면 타입 에러가 발생하지 않는다.

```ts
const obj = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: 'present',
};
const r: Room = obj; // 정상
```

이와 같이 잉여 속성 체크와 할당 가능 검사는 별도로 이루어진다.  
타입스크립트는 런타임에 예외를 발생시킬 코드 뿐만 아니라, 의도와 다르게 실행될 수 있는 코드도 함께 잡아내고자 한다.  
이 때 구조적 타이핑 만으로는 한계가 있기 때문에 잉여 속성 체크를 추가로 수행한다.  

다음의 예제에서는 darkMode 속성 이름을 darkmode로 잘못 적어서 할당했다.  
이 때 darkMode는 optional한 속성이기 때문에 할당하지 않아도 문제가 없다.  
따라서 잉여 속성 체크를 하지 않는다면 타입 체크에서 에러로 잡아낼 수 없다.

```ts
interface Options {
    title: string;
    darkMode?: boolean;
}

function createWindow(options: Options) {
    if (options.darkMode) {
        setDarkMode();
    }
    // ...
}

createWindow({
    title: 'Spider Solitaire',
    darkmode: true,
    // 개체 리터럴은 알려진 속성만 지정할 수 있지만 'Options' 형식에 'darkmode'이(가) 없습니다.
    // 'darkMode'을(를) 쓰려고 했습니까?
});
```

잉여 속성 체크는 구조적 타이핑 체계의 본질은 해치지 않으면서, 객체 리터럴에 의도하지 않은 값을 삽입하는 것을 막아준다.  
구조적 타이핑 만으로는 Options 타입은 title 속성만 가진다면 어떤 값이든 할당이 가능하다.  
실제로 잉여 속성 체크를 하지 않는 일반 객체들에 대해서는 타입 에러가 발생하지 않는다.  

```ts
const o1: Options = document; // 정상
const o2: Options = new HTMLAnchorElement; // 정상

const intermediate = { darkmode: true, title: 'Ski Free' };
const o: Options = intermediate; // 정상
```

만약 잉여 속성 체크를 원치 않는다면, 인덱스 시그니처를 사용하여 추가적인 속성이 할당 가능하도록 타입을 구성할 수 있다.  
다만 이 경우 안정성을 보장하지 못할 수 있기 때문에 주의해야 한다.

```ts
interface Options {
  darkMode?: boolean;
  [otherOptions: string]: unknown;
}
const o: Options = { darkMode: true }; // 정상
```

또한 타입스크립트는 모든 속성이 선택적인 weak 타입에 대해서는 할당되는 값이 타입에 정의한 속성을 적어도 하나 가지는지 확인한다.  
구조적 타입 관점에서는 모든 객체가 weak 타입에 포함되지만, 추가적인 체크를 통해 실수를 잡아내는 것이다.  
이 때 잉여 속성 체크와는 달리 객체 리터럴 뿐만 아니라 일반 객체 할당에 대해서도 체크가 이루어진다.


```ts
interface LineChartOptions {
  logScale?: boolean;
  invertedYAxis?: boolean;
  areaChart?: boolean;
}

const opts = { logscale: true };
const o: LineChartOptions = opts;
// { logscale: boolean; }' 유형에 'LineChartOptions' 유형과 공통적인 속성이 없습니다.
```

## 12. 함수 표현식에 타입 적용하기

자바스크립트와 타입스크립트에서 함수 문장과 함수 표현식은 다르게 인식된다.  
function 키워드를 선언부에서 사용하면 함수 문장이고, 할당부에서 사용하면 함수 표현식이다.

```ts
function rollDice1(sides: number): number {/*...*/} // 문장
const rollDice2 = function (sides: number): number {/*...*/}; // 표현식
const rollDice3 = (sides: number): number => { /* ... */ }; // 표현식
```

이 때 함수 표현식을 사용하면 매개변수와 반환값 타입을 정의하는 함수 타입을 활용할 수 있다.  
아래 예시에서 rollDice는 DiceRollFn 함수 타입으로 정의되어, 매개변수 sides가 자동으로 number로 인식된다.

```ts
type DiceRollFn = (sides: number) => number;
const rollDice: DiceRollFn = sides => { /* ... */ };
```




