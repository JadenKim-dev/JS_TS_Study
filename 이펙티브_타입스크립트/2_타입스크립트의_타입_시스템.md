## 6. 편집기를 사용하여 타입 시스템 탐색하기

타입스크립트를 설치하면 자바스크립트 변환을 위한 컴파일러 tsc와 함께, 단독으로 실행 가능한 언어 서비스인 tsserver를 제공 받는다.  
에디터에서 타입스크립트 언어 서비스를 사용하도록 설정하면 자동 완성, 명세, 검색, 리팩터링 등의 기능을 사용할 수 있다.  
언어 서비스를 통해 타입스크립트의 타입 시스템에 익숙해지고, 언제 타입 유추가 이루어지는지 이해하는데 도움을 받을 수 있다.

보통 편집기 상에서 심볼에 마우스를 올리면, 해당 심볼의 유추된 타입을 확인할 수 있다.  
예를 들어 다음과 같이 타입을 명시적으로 지정하지 않아도 num이 number로 유추되었음을 확인할 수 있다.

```ts
let num = 20
// let num: number
```

또한 함수의 타입도 자동으로 추론한다.  
다음 예시에서는 반환값의 타입이 자동으로 추론되었다.

```ts
function add(a: number, b: number) {
  return a + b;
}
// function add(a: number, b: number): number
```

이 때 만약 추론된 타입과 기대한 타입이 다르다면, 타입을 기대한 대로 명시한 뒤 어디서 문제가 발생하는지 확인해야 한다.  
타입 유추는 앞서 수행된 분기문 등에 의해 영향을 받기 때문에, 이들을 살펴보면서 타입 넓히기와 좁히기 등의 개념을 잡을 수 있다.  

```ts
function logMessage(message: string | null) {
    if (message) {
        // (parameter) message: string
        message
    }
}
```

또한 객체의 개별 속성들의 유추된 타입을 확인하는 것도 가능하다.

```ts
const foo = {
    // (property) x: number[]
    x: [1, 2, 3],
    bar: {
        name: 'Fred'
    }
};
```

연산자 체인의 중간에서 추론된 제네릭 타입을 확인하기 위해서, 중간에 호출된 메서드의 명세를 확인할 수 있다.  
다음의 예제에서는 split 결과의 제네릭 타입이 string임을 확인할 수 있다.

```ts
path.split('/').slice(1).join('/') 
//              -----
// (method) Array<string>.slice(start?: number, end?: number): string[]
```

언어 서비스에서 타입 오류로 판단하는 부분을 살펴보는 것도 도움이 된다.  

```ts
function getElement(elOrId: string | HTMLElement | null): HTMLElement {
  if (typeof elOrId === 'object') {
    return elOrId; 
//  ~~~~~~~~~~~~~~ 'HTMLElement | null' 형식은 'HTMLElement' 형식에 할당할 수 없습니다.
  } else if (elOrId === null) {
    return document.body;
  } else {
    const el = document.getElementById(elOrId);
    return el;
//  ~~~~~~~~~~ 'HTMLElement | null' 형식은 'HTMLElement' 형식에 할당할 수 없습니다.
  }
}
```

위 예제에서 getElement의 반환 타입은 HTMLElement로 정의되어 있다.  
첫번째 오류는 elOrId의 typeof를 object로 확인했다고 해도, typeof null도 마찬가지로 object이기 때문에 발생했다.  
또한 두번째 오류는 document.getElementById 가 null을 반환할 수 있기 때문에 발생했다.  
두 경우 모두 null 체크를 해서 필요한 경우 예외를 던지도록 구현해야 한다.

또한 타입스크립트 언어 서비스를 이용하면 정의로 이동(Go to Definition)하는 기능을 에디터에서 사용할 수 있다.  
예를 들어 다음과 같이 fetch를 사용하는 코드에서 정의로 이동 기능을 사용해서 fetch의 타입 선언으로 이동할 수 있다.

```ts
const response = fetch('...')

// lib.dom.d.ts
declare function fetch(
    input: RequestInfo, init?: RequestInit
): Promise<Response>
```

동일한 방식으로 RequestInfo, RequestInit의 타입 선언으로 이동할 수 있다.  
이를 통해 라이브러리가 어떻게 설계되었는지를 살펴볼 수 있어서, 오류를 찾아내는데 도움을 받을 수 있다.

## 7. 타입이 값들의 집합이라고 생각하기

타입스크립트의 타입은 특정 변수에 할당할 수 있는 값들의 집합이라고 할 수 있다.  
예를 들어 number 타입은 모든 숫자값의 집합으로 이해할 수 있다.  
strictNullChecks는 null과 undefined를 모든 타입의 집합에 포함시킬지를 결정하는 값으로 이해할 수 있다.

never 타입은 아무 값도 포함하지 않는 공집합이며, 따라서 어떤 값도 never 타입의 변수에 할당할 수 없다.

```ts
const x: never = 12;
   // ~ '12' 형식은 'never' 형식에 할당할 수 없습니다.
```

그 다음으로 작은 집합은 하나의 값만 포함하는 리터럴 타입(유닛 타입)이다.  
두 개 이상의 값을 할당 가능하게 하려면 유니온 연산자(|)로 묶어서 합집합으로 만들면 된다.  

```ts
type A = 'A';
type B = 'B';
type Twelve = 12;

type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
```

타입 오류에서는 '~~ 형식을 ~~ 형식에 할당할 수 없습니다.' 와 같은 메시지를 자주 확인할 수 있다.  
집합 관점에서 타입 체커는 한 집합이 다른 집합의 부분 집합에 해당하는지를 체크한다.

```ts
const ab: AB = Math.random() < 0.5 ? 'A' : 'B'; // 정상, {"A", "B"}는 {"A", "B"}의 부분 집합입니다.
const ab12: AB12 = ab; // 정상, {"A", "B"}는 {"A", "B", 12}의 부분 집합입니다.

declare let twelve: AB12;
const back: AB = twelve; 
    //~~~~ 'AB12' 형식은 'AB' 형식에 할당할 수 없습니다.
    //     '12' 형식은 'AB' 형식에 할당할 수 없습니다.
```

위에서 다룬 타입들은 원소의 개수가 한정되어 있지만, 일반적으로 다루는 타입들은 값의 개수가 무한대이다.  
일반적인 타입들은 다음과 같이 무수히 많은 원소를 일일이 유니온해서 추가한 것으로 이해할 수 있다.

```ts
type Int = 1 | 2 | 3 | 4 | 5 // | ...
```

이제 이전에 살펴봤던 구조적 타이핑을 다시 한 번 살펴보자.  
다음과 같이 id 속성을 가진 Identified 인터페이스를 정의했다면, 해당 타입에는 id 외의 다른 잉여 속성들을 함께 가지고 있는 객체들도 할당이 가능하다.  
즉 string 타입의 id 프로퍼티만 가지고 있으면 어떤 타입이든 Identified의 부분집합이 되는 것이다.

```ts
interface Identified {
  id: string;
}
```

이러한 개념을 바탕으로 & 연산자를 살펴보자.  
다음의 예시에서는 Person과 Lifespan을 & 연산자로 묶어서 PersonSpan 타입을 정의하고 있다.

```ts
interface Person {
  name: string;
}

interface Lifespan {
  birth: Date;
  death?: Date;
}

type PersonSpan = Person & Lifespan;
```

이 때 타입 연산자는 타입의 속성들이 아닌, 타입의 범위에 대해 적용됨을 기억해야 한다.  
Person과 Lifespan은 자신이 정의하지 않은 속성을 함께 가진 값들도 범위에 포함한다.  
따라서 이 둘의 교집합은 각 타입에서 정의한 속성들을 모두 가지고 있는 값들로 구성된다.

```ts
const ps: PersonSpan = {
    name: 'Alan Turing',
    birth: new Date('1912/06/23'),
    death: new Date(‘1954/06/07'),
};
```

keyof를 통해 특정 타입에서 정의한 키의 목록을 추출할 수 있다.  
& 연산을 하면 두 타입의 키들이 합쳐진 것으로 키 목록이 늘어나고, | 연산을 하면 공통으로 기지고 있는 키로 키 목록이 줄어든다.  
Person과 Lifespan의 공통 키는 없기 때문에, | 연산을 한 뒤 keyof를 하면 never 타입이 된다.

```ts
type T = keyof (Person & Lifespan); // 'name' | 'birth' | 'death'
type K = keyof (Person | Lifespan); // never
```

해당 개념을 등식으로 표현하면 다음과 같다.  
& 연산을 하면 두 타입의 키가 합쳐지고, | 연산을 하먄 공통 키만 남게 된다.

```ts
keyof (A & B) = (keyof A) | (keyof B)
keyof (A | B) = (keyof A) & (keyof B)
```

타입 연산 외에, extends 키워드도 타입 간 관계를 나타낼 때 많이 사용한다.  
집합의 관점에서 특정 타입이 extends 하는 타입의 부분집합임을 선언하는 것이라고 이해할 수 있다.  
다음 예시에서 PersonSpan는 Person의 모든 키를 가지면서 자신의 키를 추가로 가지기 때문에 Person의 부분집합이 된다.

```ts
interface Person {
  name: string;
}
interface PersonSpan extends Person {
  birth: Date;
  death?: Date;
}
```

타입스크립트에서는 extends한 타입을 서브타입이라고 말한다.  
아래의 예시에서 Vector3D는 Vector2D의 서브타입이고, Vector2D는 Vector1D의 서브타입이다.  
다른 언어에서 extends는 타입 간의 상속 관계를 맺게 하지만, 타입스크립트에서는 부분 집합 관계를 설정하는 것이라고 이해하는게 더 적절하다.  
Vector3D는 Vector2D의 부분 집합이고, Vector2D는 Vector1D의 부분집합이다.

```ts
interface Vector1D { x: number; }
interface Vector2D extends Vector1D { y: number; }
interface Vector3D extends Vector2D { z: rumiber; }
```

extends는 제네릭의 한정자로도 쓰이며, 이 때에는 제네릭을 특정 집합의 부분집합으로 제한하는 것으로 이해할 수 있다.

```ts
function getKey<K extends string>(val: any, key: K) {
  // ...
}
```

위 예시에서 제네릭 타입 K가 string 타입을 상속한다는 의미로 해석하면 잘 이해가 되지 않는다.  
하지만 K가 string의 부분집합이라는 의미로 해석하면, 이에 포함되는 string 리터럴 타입, 리터럴 타입의 유니온 등이 포함될 수 있음을 이해할 수 있다.

```ts
getKey({}, 'x');
getKey({}, Math.random() < 0.5 ? 'a' : 'b');
getKey({}, document.title);
getKey({}, 12); // 오류: '12' 형식의 인수는 'string' 형식의 매개변수에 할당될 수 없습니다.
```

집합의 개념을 이용하면 객체의 키 타입을 반환하는 keyof 연산자를 더 잘 이해할 수 있다.  
다음 예시에서 sortBy 메서드의 제네릭 K는 T의 키 타입의 부분집합으로 제한되었다.  
이에 따라 제네릭 T로 Point 타입을 사용하면 K에는 `'x' | 'y'` 유니온 타입의 부분집합만 할당 가능하다.  
다른 임의의 문자열은 해당 유니온 타입의 부분집합이 아니므로 할당될 수 없다.

```ts
function sortBy<K extends keyof T, T>(vals: T[], key: K): T[] {
  // ...
}

interface Point {
  x: number;
  y: number;
}

const pts: Point[] = [{x: 1, y: 1}, {x: 2, y: 0}];
sortBy(pts, 'x');
sortBy(pts, 'y');
sortBy(pts, Math.random() < 0.5 ? 'x' : 'y');
sortBy(pts, 'z'); // 오류, 'z' 형식의 인수는 '"x" | "y"' 형식의 매개변수에 할당될 수 없습니다
```

엄격한 상속 관계가 아닌 타입은 집합 관점에서 더 잘 설명 될 수 있다.  
예를 들어 `sring | number`와 `string | Date` 사이의 인터섹션은 string이다.  
string이 이들을 상속했다는 식으로는 설명이 어렵지만, string이 두 타입의 부분집합이리는 점은 쉽게 이해할 수 있다.

배열과 튜플의 관계에 대해서도 살펴보자.  
배열을 변수에 할당하면 해당 변수의 타입은 배열로 유추된다.  
이 때 배열은 튜플의 부분집합이 아니기 때문에, 튜플 타입으로 선언한 변수에는 해당 변수의 값을 할당할 수 없다.  
(튜풀이 배열의 부분집합이다.)

```ts
const list = [1, 2]; // 타입은 number[]
const tuple: [number, number] = list;
//    ~~~~~ 'number[]' 타입은 '[number, number]' 타입의 0, 1 속성에 할당할 수 없습니다.
```

이번엔 튜플 간의 관계를 살펴보자.  
숫자 세 개로 이루어진 triple 튜플은 값 두개로 이루어진 double 튜플에 할당 가능할 것으로 생각할 수 있다.  
하지만 이는 불가능하며, 그 이유는 타입스크립트가 튜플을 모델링할 때 배열의 length 값을 함께 반영했기 때문이다.  
예를 들어 double 튜플 타입은 `{0: number, 1: number, length: 2}` 로 모델링 되어있다.  
이는 각 길이의 튜플 타입을 구분하기 위한 합리적인 모델링이다.

```ts
const triple: [number, number, number] = [1, 2, 3];
const double: [number, number] = triple;
// [number, number, number] 형식은 [number, number] 형식에 할당할 수 없습니다.
// 'length' 속성의 형식이 호환되지 않습니다. '3' 형식은 '2' 형식에 할당할 수 없습니다.
```

타입은 값의 집합이기 때문에, 동일한 값의 집합을 가지는 타입은 동일한 타입이며, 따라서 중복 정의할 필요가 없다.  
또한 타입에서 특정 값을 배제하는 식으로 타입을 정의하는 것은 불가능하다.  
예를 들어 정수 타입을 정의하거나, 0을 제외한 number로 타입을 정의하는 것은 불가능하다.  
Exclude 타입 연산은 그 결과가 이러한 조건을 만족할 때에만 유효하게 동작한다.

```ts
type T = Exclude<string | Date, string|number>; // Date
type NonZeroNums = Exclude<number, 0>; // number
```

- never = 공집합
- 리터럴 타입 = 원소가 1개인 집합
- 값이 T에 할당 가능 = 값이 T의 원소
- T1이 T2에 할당 가능 = T1이 T2의 부분 집합
- T1이 T2를 상속 = T1이 T2의 부분 집합
- T1 | T2 = T1과 T2의 합집합
- T1 & T2 = T1과 T2의 교집합
- unknown = 전체(universal) 집합

## 타입 공간과 값 공간의 심벌 구분하기

타입스크립트의 심벌은 타입 공간이나 값 공간에 존재할 수 있다.  
두 공간에 동일한 이름의 심볼이 존재할 수도 있으며, 이 경우 상황에 따라 값 또는 타입으로 다르게 사용된다.  
예를 들어 다음의 예제에서 Cylinder는 타입 공간과 값 공간 모두에 정의되어 있으나, 서로 아무런 관계도 가지지 않는다.

```ts
interface Cylinder {
  radius: number;
  height: number;
}
const Cylinder = (radius: number, height: number) => ({radius, height});
```

이로 인해 혼란을 야기하기도 한다.  
다음의 예제의 원래 의도는 shape의 타입이 Cylinder 인지를 확인하는 것이다.  
하지만 런타임 연산자인 instanceof를 사용함에 따라 Cylinder가 값으로 참조되었다.

```ts
function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    console.log(shape.radius);
                    //~~~~~~ {} 형식에 'radius' 속성이 없습니다.
  }
}
```

이와 같이 심벌이 값인지 타입인지는 전체 맥락을 살펴봐야 알 수 있다.  
일반적으로 type, interface 뒤에 나오는 심벌은 타입으로, const, let 뒤에 나오는 심벌은 값으로 구분하면 된다.  

```ts
type T1 = 'string literal';
type T2 = 123;
const v1 = 'string literal';
const v2 = 123;
```

타입스크립트에서 타입과 값은 번갈아 나오는 경우가 많다.  
타입 선언(:) 또는 단언문(as) 뒤에 나오는 심벌은 타입이고, 할당(=) 뒤에 나오는 것은 값이다.

```ts
interface Person {
  first: string;
  last: string;
}

const p: Person = { first: 'Jane', last: 'Jacobs' };
//    -           --------------------------------- 값
//       ------                                     타입

function email(p: Person, subject: string, body: string): Response {
//       ----- -          -------          ----                    값
//                ------           ------        ------   -------- 타입
  // ...
}
```

class와 enum은 상황에 따라 타입과 값으로 모두 사용될 수 있다.  
클래스가 타입으로 사용될 때에는 속성, 메서드와 같은 형태를 참조하고, 값으로 사용될 때에는 생성자가 참조된다.

```ts
class Cylinder {
    radius = 1;
    height = 1;
}

function calculateVolume(shape: unknown) {
    if (shape instanceof Cylinder) {
        shape // 타입 Cylinder
        shape.radius // 타입 number
    }
}
```

typeof는 값과 타입 중 어디에 쓰이는지에 따라서 다르게 동작하는 연산자이다.  
타입에 쓰일 경우에는 값을 읽어서 타입을 반환하는 식으로 동작한다.  
이를 통해 타입을 type 구문으로 재정의하여 이름을 붙이거나, 객체 정의에서 타입을 추출하는 것이 가능하다.    
이와 달리 값에 쓰일 경우에는 자바스크립트 런타임 타입을 문자열로 반환하는 식으로 동작한다.  
자바스크립트 런타임에는 6가지 타입만 존재(string, number, boolean, undefined, object, function)하기 때문에 타입스크립트 타입보다 훨씬 단순하게 동작한다.

```ts
type T1 = typeof p; // 타입은 Person
type T2 = typeof getResponse; // 타입은 (p: Person, subject: string, body: string) => Response
const v1 = typeof p; // 값은 "object"
const v2 = typeof email; // 값은 "function"
```

클래스의 경우 맥락에 따라 값과 타입으로 모두 사용이 가능했다.  
클래스에 typeof를 적용할 때에는 클래스의 값에 해당하는 생성자를 사용해서 타입을 추출한다.  
typeof가 값에 쓰일 때에는 생성자의 런타임 타입에 맞게 'function' 문자열이 반환된다.  
타입이 쓰일 때에는 클래스의 생성자 타입이 추출되어 반환된다.

```ts
const v = typeof Cylinder; // 값이 "function"
type T = typeof Cylinder; // 타입이 typeof Cylinder

declare let fn: T;
const c = new fn(); // 타입이 Cylinder
```






