## 14. 타입 연산과 제너릭 사용으로 반복 줄이기

소프트웨어 개발에서 중복을 줄이는 것은 기본적인 원칙이다.
이는 타입에 대해서도 동일하게 적용되며, 중복이 많아질수록 오류를 내포할 확률이 높아진다.  
다음의 예제에서는 타입 간 관계 설정이 되지 않아서, Person에 추가 속성이 생겨도 PersonWithBirthDate에는 반영되지 않는다. 

```ts
interface Person {
  firstName: string;
  lastName: string;
}
interface PersonWithBirthDate {
  firstName: string;
  lastName: string;
  birth: Date;
}
```

타입 간에도 관계를 매핑하는 방법을 익혀서 중복을 줄이기 위해 노력해야 한다.  
가장 간단하게 중복을 제거하는 방법은 타입에 이름을 붙이는 것이다.

```ts
function distance(a: {x: number, y: number}, b: {x: number, y: number}) {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}

// 매개변수 타입의 중복을 제거
interface Point2D {
  x: number;
  y: number;
}
function distance(a: Point2D, b: Point2D) {/*...*/}
```

또한 함수 시그니처가 완전히 동일한 경우에는 명명된 함수 타입을 통해서 중복을 제거할 수 있다.

```ts
type HTTPFunction = (url: string, opts: Options) => Promise<Response>;
const get: HTTPFunction = (url, opts) => {/* ... */ };
const post: HTTPFunction = (url, opts) => {/* ... */ };
```

만약 타입이 다른 타입의 필드들을 포함하고 있다면, 한 인터페이스가 다른 인터페이스를 확장하게 해서 중복을 제거할 수 있다.  
필드의 부분집합을 공유하고 있는 경우에도 공통 필드를 타입으로 정의해서 기반 타입으로 사용하면 된다.

```ts
interface Person {
  firstName: string;
  lastName: string;
}
interface PersonWithBirthDate extends Person {
  birth: Date;
}
```

이미 존재하는 타입을 인라인에서 간단하게 확장할 때에는 인터섹션 연산자(&)를 사용할 수 있다.

```ts
type PersonWithBirthDate = Person & { birth: Date };
```








