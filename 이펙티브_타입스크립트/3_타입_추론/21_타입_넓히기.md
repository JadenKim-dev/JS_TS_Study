# 21. 타입 넓히기

타입스크립트에서는 타입 유추 과정에서 할당한 상수 값을 바탕으로 타입을 결정해야 한다.  
이는 단일 값을 바탕으로 할당 가능한 값의 집합인 타입을 유추하는 것으로, 타입 넓히기라고 부른다.

타입 시스템에서는 타입 넓히기를 할 때 작성자의 의도를 추측하고, 명확성과 유연성 사이에서 균형을 유지하려고 한다.  
하지만 언제나 그 추측한 답이 옳을 수는 없다.  
예를 들어 다음과 같이 3D 벡터 타입과, 해당 타입에서 특정 요소 값을 반환하는 함수를 정의했다고 하자.  
이 때 변수 x에 값 'x'를 할당하여 함수의 매개변수로 사용하려고 하면 타입 오류가 발생한다.

```ts
interface Vector3 {
  x: number;
  y: number;
  z: number;
}
function getComponent(vector: Vector3, axis: "x" | "y" | "z") {
  return vector[axis];
}

let x = "x"; // string
getComponent({ x: 10, y: 20, z: 30 }, x); // 'string' 형식의 인수는 'x'|'y'|'z' 형식에 할당할 수 없습니다.
```

이는 변수 x가 string 타입으로 유추되었기 때문에 발생하는 문제이다.  
let으로 변수를 선언하면 해당 변수에는 다양한 값을 할당할 수 있기 때문에, string literal 타입이 아닌 일반 string 타입으로 유추된다.

사실 'x' 값의 상위 집합에는 `any`, `string | number` 등의 다양한 타입이 존재한다.  
그 중 string을 골랐기 때문에, 변수가 선언된 후로 단일한 타입만 할당한다는 원칙을 지킬 수 있게 되었다.

```ts
let x = "x";
x = "a";
x = "Four score and seven years ago...";
x = 3; // 'number' 형식은 'string' 형식에 할당할 수 없습니다.
```

## const로 타입 넓히기를 제어하기

타입 좁히기를 제어하는 가장 편한 방법은 const를 사용하는 것이다.  
const로 변수를 선언하면 더 좁은 범위의 타입으로 추론된다.  
앞선 예제에서도 x 변수를 const로 선언하면 타입 리터럴 'x'로 추론되어 에러가 사라진다.

```ts
const x = "x"; // 'x'
getComponent({ x: 10, y: 20, z: 30 }, x);
```

## 객체, 배열의 타입 넓히기

하지만 객체나 배열의 경우에는 const로 선언해도 타입 넓히기를 제어할 수 없다.  
배열의 경우에는 const로 선언하더라도 여전히 튜플이 아닌 배열로 추론되며, 각 요소에 대해서는 let으로 할당한 것처럼 추론된다.  
따라서 각 요소를 수정하는 것이 가능하다.  
만약 요소로 여러 타입이 포함되어 있다면 각 타입의 유니온으로 추론된다.

```ts
const numbers = [1, 2]; // number[]
const mixed = ['x', 1]; // (string|number)[]
mixed[0] = 1; // 정상
```

객체의 속성들도 마찬가지로 let으로 할당한 것처럼 추론된다.  
각 속성들을 수정할 수 있으며, 다른 속성을 추가하는 것은 불가능하다.  
이러한 점 때문에 객체 리터럴은 한 번에 만들어야 한다.

```ts
const v = {
  x: 1,
};
v.x = 3; // 정상
v.x = '3'; // '3' 형식은 'number' 형식에 할당할 수 없습니다.
v.y = 4; // '{ x: number; }' 형식에 'y' 속성이 없습니다.
```

## 타입 추론의 강도를 제어하는 법

타입 추론의 강도를 직접 제어하려면 타입스크립트의 동작을 재정의해야 한다.  
이를 위해 명시적으로 타입 구문을 지정하거나, 함수의 매개변수에 기본값을 힐당하는 등의 방법으로 타입 체커에 추기적린 문맥을 제공할 수 있다.

```ts
const v: { x: 1|3|5 } = {
  x: 1,
};

function greet(name = "Guest"): string { // name은 string
    ...
}
```










