# 29 사용할 때는 너그럽게, 생성할 때는 엄격하게

함수 시그니처에서 매개변수의 타입 범위가 넓으면 유연한 사용이 가능해진다.  
하지만 반환값의 타입 범위가 넓으면 반환값의 타입을 좁혀서 사용해야 해서 함수 사용이 어려워진다.  

아래 예제에서는 경계 박스의 뷰포트를 계산하는 viewportForBounds, 카메라의 설정을 지정하는 setCamera 메서드를 정의했다.  
viewportForBounds의 반환값을 이용하여 setCamera를 호출하므로, 전자의 반환 타입과 후자의 매개변수 타입이 동일하다.

```ts
declare function setCamera(camera: Cameraoptions): void;
declare function viewportForBounds(bounds: LngLatBounds): CameraOptions;
```

매개변수와 반환값에 적용된 타입은 매우 유연하게 정의되었다.  
대부분의 속성이 optional이며, 유니온을 이용하여 다양한 형태로 값을 넘길 수 있게 했다.

```ts
// 유니온으로 다양한 형태로 매개변수를 받음
type LngLat =
  { Ing: number; tat: number; } |
  { Ion: number; lat: number; } |
  [number, number];

// 유니온으로 다양한 형태로 매개변수를 받음
type LngLatBounds =
  { northeast: LngLat, southwest: LngLat } |
  [LngLat, LngLat] |
  [number, number, number, number];

// 모든 필드가 선택적
interface CameraOptions {
  center?: LngLat;
  zoom?: number;
  bearing?: number;
  pitch?: number;
}
```

이제 viewportForBounds를 호출한 결과를 이용하여 페이지의 url을 설정하는 로직을 구현해보자.  
이 때 비구조화해서 필요한 변수를 추출하려고 하면 타입 에러가 발생한다.  
반환값의 속성을 사용하기 위해서는 유니온 타입 각각을 구분할 수 있도록 분기문을 작성해야 한다.  
또한 비구조화에 성공한 zoom 변수도 `number | undefined`로 추론되기 때문에, 숫자로 사용하기 위해서는 null 체크를 해야 한다.

```ts
function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  const { center: { lat, lng }, zoom } = camera;
  // ... 형식에 'lat', 'lng' 속성이 없습니다.
  zoom; // number | undefined
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```

위와 같이 반환 타입이 넓으면 분기문 등을 통해 타입을 좁혀야 하기 때문에 사용이 불편하다.  
타입 설계를 개선해서 함수가 보다 정확한 타입으로 값을 반환하도록 변경해보자.  
먼저 좁은 타입인 LngLat과, 이와 유사한 데이터 구조를 허용하는 LngLatLike를 분리해서 정의한다.  
이 때 매개변수에서는 LngLatLike를 사용해서 다양한 입력 형태를 지원하게 하고, 반환값에서는 LngLat을 사용해서 더 좁은 타입을 반환하도록 한다.

또한 optional하지 않은 속성만으로 채워진 Camera 타입과, center에 한해서 optional을 허용하는 CameraOptions 타입을 분리한다.  
이 때 CameraOptions의 center는 LngLatLike 타입으로 정의하여 유연하게 데이터를 받을 수 있게 한다.  
이제 Camera는 반환 타입으로, CameraOptions는 매개변수 타입으로 사용한다.

```ts
interface LngLat {
  lng: number;
  lat: number;
}

type LngLatLike = LngLat | { lon: number; lat: number; } | [number, number];

interface Camera {
  center: LngLat;
  zoom: number;
  bearing: number;
  pitch: number;
}

interface CameraOptions extends Omit<Partial<Camera>, 'center'> {
  center?: LngLatLike;
}

type LngLatBounds = 
  { northeast: LngLatLike; southwest: LngLatLike; } | 
  [LngLatLike, LngLatLike] | 
  [number, number, number, number];

declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): Camera;
```

이제 LngLat으로 좁은 타입이 적용되어 비구조화 할당문이 정상 동작한다.  
또한 zoom 속성도 필수 속성으로 정의되어 number로 바로 사용할 수 있다.
