# 46. 타입 선언과 관련된 세 가지 버전 이해하기

타입스크립트를 사용하면 라이브러리의 버전, 타입 선언(`@types`), 타입스크립트의 버전을 모두 고려해야 하기 떄문에, 의존성 관리가 더 복잡해진다.  
세 가지 버전 중 하나라도 맞디 않으면 엉뚱한 곳에서 타입 에러가 발생할 수 있다.

예를 들어 다음과 같이 react 의존성과 타입 의존성을 설치했다고 하자.  
두 의존성의 메이저 버전과 마이너 버전(16.8)은 일치하지만, 패치 버전(6, 19)은 일치하지 않는다.  
보통 라이브러리의 메이저 버전과 마이너 버전이 동일하면 공개 API의 사양이 변경되진 않는다.  
따라서 패치 버전은 일반 의존성과 타입 의존성이 개별적으로 관리되며, 타입 선언 자체에 누락이나 버그가 있으면 이에 맞춰서 개별적으로 패치 버전을 업그레이드하며 관리한다.

```ts
$ npm install react
+ react@16.8.6
$ npm install —save-dev (atypes/react
+ @types/react@16.8.19
```

다만 이렇게 개별적으로 관리가 되다 보니, 두 의존성의 버전이 불일치하는 경우 한쪽의 버전을 낮추거나 내리는 식으로 버전을 맞춰줘야 한다.  
또한 프로젝트의 타입스크립트 버전과 타입 의존성에서 사용하는 타입스크립트 버전이 다른 경우에도 버전을 맞춰줘야 한다.  
(typeVersions를 통해 각 타입스크립트 버전 별로 다른 타입 정보를 제공할 수 있으나, 그렇게 정의된 경우가 별로 없다.)  
npm 의존성 설치 시 다음과 같이 원하는 버전을 지정해서 설치할 수 있다.

```ts
$ npm install --save-dev @types/lodash@ts3.1
```

또는 의존성을 가진 라이브러리에서 동일한 @types 의존성의 다른 버전을 사용하고 있을 수도 있다.  
이 경우 npm은 보통 중첩된 폴더에 별도로 해당 버전을 설치해서 문제를 해결한다.  

```ts
node_modules/
  @types/
    foo/
      index.d.ts @1.2.3
    bar/
      index.d.ts
node_modules/
  @types/
    foo/
      index.d.ts @2.3.4
```

그러나 전역 네임스페이스로 사용하는 타입 선언 모듈이라면 여전히 충돌이 발셍할 수 있다.  
이 경우에는 `npm ls @types/foo` 명령어로 어디서 중복된 타입 선언이 발생했는지 확인하고, 버전이 일치하도록 업데이트해야 한다.

라이브러리의 타입을 공개할 때 @types에 포함시키는 대신, 라이브러리 내부에 타입 선언을 번들링 할 수도 있다.  
보통 타입스크립트로 작성된 프로젝트에 대해서 컴파일러를 통해 타입 선언을 생성한 경우에 이렇게 한다.  
package.json의 types 항목에 타입 선언이 저장된 d.ts 파일을 지정하면 된다.

```json
{
  "name": "left-pad",
  "version": "1.3.0",
  "description": "String left pad",
  "main": "index.js",
  "types": "index.d.ts"
  // ...
}
```

이 방법을 사용하면 타입의 버전과 라이브러리의 버전이 불일치하는 문제가 발생하지 않는다.  
하지만 라이브러리 내부에 존재한 타입 선언이 잘못된 경우 타입만 다른 버전으로 변경하는 등의 조치가 불가능하다.
